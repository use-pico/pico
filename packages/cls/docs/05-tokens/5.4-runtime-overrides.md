# 5.4 Runtime Overrides

## Table of Contents
- [5.1 Contract Declaration](./5.1-contract-declaration.md)
- [5.2 Token Definition](./5.2-token-definition.md)
- [5.3 Inheritance](./5.3-inheritance.md)
- [5.4 Runtime Overrides](./5.4-runtime-overrides.md) *(current)*

---

Runtime overrides are CLS's **dynamic styling superpower**. They allow you to change token values on-the-fly without modifying your base definitions. This chapter explores how to use runtime overrides for dynamic theming, user preferences, and contextual styling.

## **What are Runtime Overrides?** 🤔

Runtime overrides allow you to **dynamically change token values** when calling `create()`. Unlike definition-time overrides that modify the base token definitions, runtime overrides are applied **per-instance** and don't affect the original CLS instance.

### **Key Concepts** 🎯

- **Dynamic**: Token values change at runtime, not compile time
- **Instance-specific**: Overrides only affect the current `create()` call
- **Non-destructive**: Original token definitions remain unchanged
- **Type-safe**: TypeScript ensures only valid tokens can be overridden

## **How Runtime Overrides Work** ⚙️

### **1. Basic Token Override** 🔄

Use the `token` property in `create()` to override specific token values:

```typescript
const ButtonTokens = cls({
  token: {
    "color.bg": ["primary", "secondary", "danger"],
    "color.text": ["primary", "secondary", "danger"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      danger: ["bg-red-600"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-white"],
      danger: ["text-white"]
    }
  })
}));

// Runtime override: change primary color to purple
const purpleButton = ButtonTokens.create(({ what, override }) => ({
  token: override.token({
    "color.bg": {
      primary: ["bg-purple-600"]  // Override at runtime
    }
  })
}));

// Result: purpleButton.root() returns "bg-purple-600 text-white"
```

### **2. Multiple Token Overrides** 🎨

Override multiple tokens in a single `create()` call:

```typescript
const CardTokens = cls({
  token: {
    "color.bg": ["surface", "surfaceSecondary"],
    "color.border": ["default", "focus"],
    "spacing.p": ["sm", "md", "lg"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      surface: ["bg-white"],
      surfaceSecondary: ["bg-gray-50"]
    },
    "color.border": {
      default: ["border-gray-300"],
      focus: ["border-blue-500"]
    },
    "spacing.p": {
      sm: ["p-4"],
      md: ["p-6"],
      lg: ["p-8"]
    }
  })
}));

// Runtime override: dark theme variant
const darkCard = CardTokens.create(({ what, override }) => ({
  token: override.token({
    "color.bg": {
      surface: ["bg-gray-900"],
      surfaceSecondary: ["bg-gray-800"]
    },
    "color.border": {
      default: ["border-gray-700"],
      focus: ["border-blue-400"]
    }
  })
}));

// Result: darkCard.root() returns dark theme classes
```

### **3. Partial Token Overrides** 🎯

Override only specific variants within a token group:

```typescript
const AlertTokens = cls({
  token: {
    "alert.variant": ["info", "success", "warning", "error"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "alert.variant": {
      info: ["bg-blue-50", "border-blue-200", "text-blue-800"],
      success: ["bg-green-50", "border-green-200", "text-green-800"],
      warning: ["bg-yellow-50", "border-yellow-200", "text-yellow-800"],
      error: ["bg-red-50", "border-red-200", "text-red-800"]
    }
  })
}));

// Runtime override: only change success variant
const customSuccessAlert = AlertTokens.create(({ what, override }) => ({
  token: override.token({
    "alert.variant": {
      success: ["bg-emerald-50", "border-emerald-200", "text-emerald-800"]
    }
  })
}));

// Other variants remain unchanged
// - info: still uses blue colors
// - warning: still uses yellow colors  
// - error: still uses red colors
// - success: now uses emerald colors
```

## **Runtime Override Patterns** 🎨

### **1. Theme Switching** 🌈

Dynamically switch between themes at runtime:

```typescript
const ThemeTokens = cls({
  token: {
    "theme.color.bg": ["surface", "surfaceSecondary"],
    "theme.color.text": ["primary", "secondary"],
    "theme.color.border": ["default", "focus"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "theme.color.bg": {
      surface: ["bg-white"],
      surfaceSecondary: ["bg-gray-50"]
    },
    "theme.color.text": {
      primary: ["text-gray-900"],
      secondary: ["text-gray-600"]
    },
    "theme.color.border": {
      default: ["border-gray-300"],
      focus: ["border-blue-500"]
    }
  })
}));

// Light theme (default)
const lightTheme = ThemeTokens.create();

// Dark theme override
const darkTheme = ThemeTokens.create(({ what, override }) => ({
  token: override.token({
    "theme.color.bg": {
      surface: ["bg-gray-900"],
      surfaceSecondary: ["bg-gray-800"]
    },
    "theme.color.text": {
      primary: ["text-gray-100"],
      secondary: ["text-gray-400"]
    },
    "theme.color.border": {
      default: ["border-gray-700"],
      focus: ["border-blue-400"]
    }
  })
}));

// High contrast theme override
const highContrastTheme = ThemeTokens.create(({ what, override }) => ({
  token: override.token({
    "theme.color.bg": {
      surface: ["bg-black"],
      surfaceSecondary: ["bg-gray-900"]
    },
    "theme.color.text": {
      primary: ["text-white"],
      secondary: ["text-gray-300"]
    },
    "theme.color.border": {
      default: ["border-white"],
      focus: ["border-yellow-400"]
    }
  })
}));
```

### **2. User Preferences** 👤

Override tokens based on user preferences:

```typescript
const UserPreferenceTokens = cls({
  token: {
    "preference.color": ["primary", "secondary"],
    "preference.size": ["text", "spacing"],
    "preference.contrast": ["normal", "high"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "preference.color": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"]
    },
    "preference.size": {
      text: ["text-base"],
      spacing: ["p-4"]
    },
    "preference.contrast": {
      normal: ["opacity-100"],
      high: ["opacity-100"]
    }
  })
}));

// User preference function
function createUserTheme(userPreferences: {
  colorScheme: "blue" | "purple" | "green";
  fontSize: "small" | "medium" | "large";
  contrast: "normal" | "high";
}) {
  return UserPreferenceTokens.create(({ what, override }) => ({
    token: override.token({
      "preference.color": {
        primary: userPreferences.colorScheme === "blue" 
          ? ["text-blue-600"]
          : userPreferences.colorScheme === "purple"
          ? ["text-purple-600"]
          : ["text-green-600"]
      },
      "preference.size": {
        text: userPreferences.fontSize === "small"
          ? ["text-sm"]
          : userPreferences.fontSize === "medium"
          ? ["text-base"]
          : ["text-lg"],
        spacing: userPreferences.fontSize === "small"
          ? ["p-3"]
          : userPreferences.fontSize === "medium"
          ? ["p-4"]
          : ["p-6"]
      },
      "preference.contrast": {
        normal: ["opacity-100"],
        high: ["opacity-100", "font-bold"]
      }
    })
  }));
}

// Usage
const userTheme = createUserTheme({
  colorScheme: "purple",
  fontSize: "large",
  contrast: "high"
});
```

### **3. Contextual Styling** 🎭

Override tokens based on context or state:

```typescript
const ContextualTokens = cls({
  token: {
    "context.state": ["default", "hover", "active", "disabled"],
    "context.importance": ["low", "medium", "high"],
    "context.location": ["header", "sidebar", "main", "footer"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "context.state": {
      default: ["opacity-100"],
      hover: ["hover:opacity-80"],
      active: ["active:opacity-60"],
      disabled: ["opacity-50", "cursor-not-allowed"]
    },
    "context.importance": {
      low: ["text-gray-500"],
      medium: ["text-gray-700"],
      high: ["text-gray-900", "font-semibold"]
    },
    "context.location": {
      header: ["bg-white", "border-b"],
      sidebar: ["bg-gray-50", "border-r"],
      main: ["bg-white"],
      footer: ["bg-gray-100", "border-t"]
    }
  })
}));

// Context-aware styling function
function createContextualStyle(context: {
  state: "default" | "hover" | "active" | "disabled";
  importance: "low" | "medium" | "high";
  location: "header" | "sidebar" | "main" | "footer";
  isHighlighted?: boolean;
}) {
  return ContextualTokens.create(({ what, override }) => ({
    token: override.token({
      "context.importance": {
        ...(context.isHighlighted && {
          low: ["text-blue-500"],
          medium: ["text-blue-700"],
          high: ["text-blue-900", "font-semibold"]
        })
      }
    })
  }));
}

// Usage
const headerStyle = createContextualStyle({
  state: "default",
  importance: "high",
  location: "header",
  isHighlighted: true
});
```

### **4. A/B Testing** 🧪

Override tokens for different test variants:

```typescript
const ABTestTokens = cls({
  token: {
    "test.button": ["primary", "secondary"],
    "test.color": ["blue", "green", "purple"],
    "test.size": ["small", "medium", "large"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "test.button": {
      primary: ["bg-blue-600", "text-white"],
      secondary: ["bg-gray-600", "text-white"]
    },
    "test.color": {
      blue: ["text-blue-600"],
      green: ["text-green-600"],
      purple: ["text-purple-600"]
    },
    "test.size": {
      small: ["text-sm", "p-2"],
      medium: ["text-base", "p-4"],
      large: ["text-lg", "p-6"]
    }
  })
}));

// A/B test variant generator
function createTestVariant(variant: "A" | "B" | "C") {
  return ABTestTokens.create(({ what, override }) => ({
    token: override.token({
      "test.button": {
        primary: variant === "A" 
          ? ["bg-blue-600", "text-white"]
          : variant === "B"
          ? ["bg-green-600", "text-white"]
          : ["bg-purple-600", "text-white"]
      },
      "test.size": {
        medium: variant === "A"
          ? ["text-base", "p-4"]
          : variant === "B"
          ? ["text-lg", "p-6"]
          : ["text-sm", "p-2"]
      }
    })
  }));
}

// Usage
const variantA = createTestVariant("A");
const variantB = createTestVariant("B");
const variantC = createTestVariant("C");
```

## **Advanced Runtime Override Techniques** 🚀

### **1. Conditional Overrides** 🎯

Use conditional logic to determine override values:

```typescript
const ConditionalTokens = cls({
  token: {
    "conditional.mode": ["light", "dark"],
    "conditional.size": ["compact", "comfortable"],
    "conditional.accessibility": ["normal", "high"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "conditional.mode": {
      light: ["bg-white", "text-gray-900"],
      dark: ["bg-gray-900", "text-gray-100"]
    },
    "conditional.size": {
      compact: ["p-2", "text-sm"],
      comfortable: ["p-4", "text-base"]
    },
    "conditional.accessibility": {
      normal: ["opacity-100"],
      high: ["opacity-100", "font-bold", "border-2"]
    }
  })
}));

// Conditional override function
function createConditionalStyle(conditions: {
  isDarkMode: boolean;
  isCompact: boolean;
  isHighContrast: boolean;
  isMobile: boolean;
}) {
  return ConditionalTokens.create(({ what, override }) => ({
    token: override.token({
      "conditional.mode": {
        light: conditions.isDarkMode 
          ? ["bg-gray-900", "text-gray-100"]
          : ["bg-white", "text-gray-900"]
      },
      "conditional.size": {
        compact: conditions.isCompact || conditions.isMobile
          ? ["p-1", "text-xs"]
          : ["p-2", "text-sm"]
      },
      "conditional.accessibility": {
        high: conditions.isHighContrast
          ? ["opacity-100", "font-bold", "border-2", "bg-yellow-100"]
          : ["opacity-100", "font-bold", "border-2"]
      }
    })
  }));
}
```

### **2. Dynamic Token Calculation** 🧮

Calculate token values dynamically:

```typescript
const DynamicTokens = cls({
  token: {
    "dynamic.spacing": ["xs", "sm", "md", "lg", "xl"],
    "dynamic.color": ["primary", "secondary", "accent"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "dynamic.spacing": {
      xs: ["p-1"],
      sm: ["p-2"],
      md: ["p-4"],
      lg: ["p-6"],
      xl: ["p-8"]
    },
    "dynamic.color": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      accent: ["text-purple-600"]
    }
  })
}));

// Dynamic calculation function
function createDynamicStyle(baseSpacing: number, colorHue: number) {
  // Calculate spacing based on base value
  const spacingMultiplier = baseSpacing / 4; // Normalize to base 4
  
  // Calculate color based on hue
  const colorClass = `text-${getColorName(colorHue)}-600`;
  
  return DynamicTokens.create(({ what, override }) => ({
    token: override.token({
      "dynamic.spacing": {
        xs: [`p-${Math.max(1, Math.floor(spacingMultiplier * 0.25))}`],
        sm: [`p-${Math.max(2, Math.floor(spacingMultiplier * 0.5))}`],
        md: [`p-${Math.max(4, Math.floor(spacingMultiplier * 1))}`],
        lg: [`p-${Math.max(6, Math.floor(spacingMultiplier * 1.5))}`],
        xl: [`p-${Math.max(8, Math.floor(spacingMultiplier * 2))}`]
      },
      "dynamic.color": {
        primary: [colorClass],
        secondary: [colorClass.replace('-600', '-500')],
        accent: [colorClass.replace('-600', '-700')]
      }
    })
  }));
}

// Helper function to convert hue to color name
function getColorName(hue: number): string {
  const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'pink'];
  const index = Math.floor((hue % 360) / (360 / colors.length));
  return colors[index];
}
```

### **3. Token Composition** 🧩

Compose tokens from multiple sources:

```typescript
const CompositionTokens = cls({
  token: {
    "composition.base": ["default", "primary", "secondary"],
    "composition.variant": ["solid", "outline", "ghost"],
    "composition.state": ["default", "hover", "active"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "composition.base": {
      default: ["bg-gray-100", "text-gray-900"],
      primary: ["bg-blue-600", "text-white"],
      secondary: ["bg-gray-600", "text-white"]
    },
    "composition.variant": {
      solid: [""],
      outline: ["border", "bg-transparent"],
      ghost: ["bg-transparent"]
    },
    "composition.state": {
      default: [""],
      hover: ["hover:opacity-80"],
      active: ["active:opacity-60"]
    }
  })
}));

// Token composition function
function composeTokens(
  base: "default" | "primary" | "secondary",
  variant: "solid" | "outline" | "ghost",
  state: "default" | "hover" | "active",
  customOverrides?: Record<string, string[]>
) {
  return CompositionTokens.create(({ what, override }) => ({
    token: override.token({
      "composition.base": {
        [base]: customOverrides?.base?.[base] || ["bg-blue-600", "text-white"]
      },
      "composition.variant": {
        [variant]: customOverrides?.variant?.[variant] || ["border", "bg-transparent"]
      },
      "composition.state": {
        [state]: customOverrides?.state?.[state] || ["hover:opacity-80"]
      }
    })
  }));
}

// Usage with custom overrides
const customComposition = composeTokens(
  "primary",
  "outline", 
  "hover",
  {
    base: {
      primary: ["bg-purple-600", "text-white"]
    },
    variant: {
      outline: ["border-2", "border-purple-600", "bg-transparent"]
    }
  }
);
```

## **Runtime Override Best Practices** 💡

### **1. Use Descriptive Names** 🏷️

Make override intentions clear:

```typescript
// ✅ Good: Clear intent
const darkThemeOverride = ThemeTokens.create(({ what, override }) => ({
  token: override.token({
    "theme.color.bg": {
      surface: ["bg-gray-900"],
      surfaceSecondary: ["bg-gray-800"]
    }
  })
}));

// ❌ Avoid: Unclear intent
const override1 = ThemeTokens.create(({ what, override }) => ({
  token: override.token({
    "theme.color.bg": {
      surface: ["bg-gray-900"],
      surfaceSecondary: ["bg-gray-800"]
    }
  })
}));
```

### **2. Keep Overrides Focused** 🎯

Override only what you need:

```typescript
// ✅ Good: Focused override
const compactSpacing = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "spacing.p": {
      md: ["p-2"]  // Only override medium spacing
    }
  })
}));

// ❌ Avoid: Overriding everything
const compactSpacing = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "spacing.p": {
      xs: ["p-1"],
      sm: ["p-1"],
      md: ["p-2"],
      lg: ["p-3"],
      xl: ["p-4"]
    },
    "color.bg": {
      primary: ["bg-blue-600"],  // Unnecessary override
      secondary: ["bg-gray-600"] // Unnecessary override
    }
  })
}));
```

### **3. Use Functions for Complex Overrides** 🔧

Create reusable override functions:

```typescript
// ✅ Good: Reusable function
function createThemeOverride(theme: "light" | "dark" | "high-contrast") {
  return ThemeTokens.create(({ what, override }) => ({
    token: override.token({
      "theme.color.bg": {
        surface: theme === "light" 
          ? ["bg-white"]
          : theme === "dark"
          ? ["bg-gray-900"]
          : ["bg-black"]
      }
    })
  }));
}

// Usage
const lightTheme = createThemeOverride("light");
const darkTheme = createThemeOverride("dark");
const highContrastTheme = createThemeOverride("high-contrast");

// ❌ Avoid: Repeated code
const lightTheme = ThemeTokens.create(({ what, override }) => ({
  token: override.token({ "theme.color.bg": { surface: ["bg-white"] } })
}));
const darkTheme = ThemeTokens.create(({ what, override }) => ({
  token: override.token({ "theme.color.bg": { surface: ["bg-gray-900"] } })
}));
```

### **4. Validate Override Values** ✅

Ensure overrides are valid:

```typescript
// ✅ Good: Validation
function createValidatedOverride(
  colorScheme: "blue" | "purple" | "green",
  size: "sm" | "md" | "lg"
) {
  // Validate inputs
  if (!["blue", "purple", "green"].includes(colorScheme)) {
    throw new Error(`Invalid color scheme: ${colorScheme}`);
  }
  if (!["sm", "md", "lg"].includes(size)) {
    throw new Error(`Invalid size: ${size}`);
  }

  return ComponentTokens.create(({ what, override }) => ({
    token: override.token({
      "color.bg": {
        primary: [`bg-${colorScheme}-600`]
      },
      "spacing.p": {
        [size]: size === "sm" ? ["p-2"] : size === "md" ? ["p-4"] : ["p-6"]
      }
    })
  }));
}

// ❌ Avoid: No validation
function createUnvalidatedOverride(colorScheme: string, size: string) {
  return ComponentTokens.create(({ what, override }) => ({
    token: override.token({
      "color.bg": {
        primary: [`bg-${colorScheme}-600`]  // Could be invalid
      },
      "spacing.p": {
        [size]: ["p-4"]  // Could be invalid
      }
    })
  }));
}
```

### **5. Document Override Behavior** 📚

Explain what overrides do:

```typescript
/**
 * Creates a runtime override for different color schemes
 * 
 * @param scheme - The color scheme to apply
 * @param intensity - The color intensity (100-900)
 * @returns A CLS instance with overridden color tokens
 * 
 * @example
 * const blueTheme = createColorSchemeOverride("blue", 600);
 * const purpleTheme = createColorSchemeOverride("purple", 700);
 */
function createColorSchemeOverride(
  scheme: "blue" | "purple" | "green",
  intensity: 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900
) {
  return ThemeTokens.create(({ what, override }) => ({
    token: override.token({
      "theme.color.bg": {
        primary: [`bg-${scheme}-${intensity}`],
        secondary: [`bg-${scheme}-${Math.max(100, intensity - 200)}`]
      },
      "theme.color.text": {
        primary: [`text-${scheme}-${intensity}`],
        secondary: [`text-${scheme}-${Math.max(100, intensity - 200)}`]
      }
    })
  }));
}
```

## **Runtime Override Benefits** ✨

### **1. Dynamic Styling** 🎨

Change appearance without code changes:

```typescript
// Theme can be changed at runtime
const currentTheme = userPreferences.darkMode ? "dark" : "light";
const themedComponent = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "color.bg": {
      surface: currentTheme === "dark" 
        ? ["bg-gray-900"] 
        : ["bg-white"]
    }
  })
}));
```

### **2. User Customization** 👤

Allow users to customize their experience:

```typescript
// User can customize colors
const userCustomized = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "color.bg": {
      primary: [userSettings.primaryColor],
      secondary: [userSettings.secondaryColor]
    }
  })
}));
```

### **3. A/B Testing** 🧪

Test different designs without deployment:

```typescript
// Test different button styles
const testVariant = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "button.variant": {
      primary: testGroup === "A" 
        ? ["bg-blue-600", "text-white"]
        : ["bg-green-600", "text-white"]
    }
  })
}));
```

### **4. Contextual Adaptation** 🎭

Adapt to different contexts:

```typescript
// Adapt to device or context
const contextualStyle = ComponentTokens.create(({ what, override }) => ({
  token: override.token({
    "spacing.p": {
      md: isMobile 
        ? ["p-2"] 
        : ["p-4"]
    },
    "typography.size": {
      base: isMobile 
        ? ["text-sm"] 
        : ["text-base"]
    }
  })
}));
```

## **When to Use Runtime Overrides** 🤔

### **✅ Use Runtime Overrides When:**

- **Dynamic theming** - Switching between light/dark themes
- **User preferences** - Customizing colors, sizes, or spacing
- **A/B testing** - Testing different design variants
- **Contextual styling** - Adapting to device, location, or state
- **Real-time customization** - Changing styles without page reload
- **Conditional styling** - Applying styles based on runtime conditions

### **❌ Avoid Runtime Overrides When:**

- **Static styling** - Styles that never change
- **Performance critical** - When object creation overhead matters
- **Simple components** - When inheritance is sufficient
- **Build-time optimization** - When you need tree-shaking
- **Complex calculations** - When overrides become too complex

## **Runtime Override Best Practices Summary** 📋

1. **Use descriptive names** for override variables and functions
2. **Keep overrides focused** - only override what you need
3. **Create reusable functions** for common override patterns
4. **Validate override values** to prevent runtime errors
5. **Document override behavior** for maintainability
6. **Consider performance** when creating many overrides
7. **Use TypeScript** for type safety in override functions
8. **Test override combinations** to ensure they work together

Runtime overrides are CLS's **dynamic styling superpower**. Use them wisely to create flexible, user-friendly, and context-aware design systems! 🚀

---

**[← Previous: Inheritance](./5.3-inheritance.md)** | **[→ Next Chapter: Slots](./../06-slots/README.md)**
