# 13.5 vs TV (Tailwind Variants)

## Table of Contents
- [13.1 Feature Table](./13.1-feature-table.md)
- [13.2 Code Comparisons](./13.2-code-comparisons.md)
- [13.3 Migration Paths](./13.3-migration-paths.md)
- [13.4 vs CVA (Class Variance Authority)](./13.4-vs-cva-class-variance-authority.md)
- [13.5 vs TV (Tailwind Variants)](./13.5-vs-tv-tailwind-variants.md) *(current)*
- [13.6 vs Stitches](./13.6-vs-stitches.md)
- [13.7 vs Vanilla Extract](./13.7-vs-vanilla-extract.md)

---

This chapter provides a **detailed comparison** between CLS and **Tailwind Variants (TV)**, a popular Tailwind-focused styling library. We'll explore their **similarities**, **differences**, and **when to choose each**.

## **What is TV?** ü§î

**Tailwind Variants (TV)** is a popular styling library designed specifically for **Tailwind CSS** users. It provides **variant-based styling** with excellent TypeScript support and a **Tailwind-first approach**.

### **TV's Core Philosophy** üéØ

- **Tailwind-first design** - Built specifically for Tailwind CSS workflows
- **Variant-based styling** - Define variants and their combinations
- **TypeScript integration** - Full type safety for variants and props
- **Simple API** - Minimal learning curve for Tailwind users
- **Framework agnostic** - Works with any React setup

## **Side-by-Side Comparison** üìä

### **Basic Button Component** üéØ

Let's compare how both libraries handle a simple button component with size and tone variants.

#### **TV Implementation** üé®

```typescript
import { tv, type VariantProps } from "tailwind-variants";

const button = tv({
  base: "inline-flex items-center justify-center rounded font-medium transition-colors",
  variants: {
    size: {
      sm: "px-3 py-1.5 text-sm",
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg",
    },
    tone: {
      primary: "bg-blue-600 text-white focus:ring-blue-500",
      secondary: "bg-gray-600 text-white focus:ring-gray-500",
      danger: "bg-red-600 text-white focus:ring-red-500",
    },
  },
  defaultVariants: {
    size: "md",
    tone: "primary",
  },
});

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof button> {
  children: React.ReactNode;
}

function Button({ children, size, tone, className, ...props }: ButtonProps) {
  return (
    <button className={button({ size, tone, className })} {...props}>
      {children}
    </button>
  );
}
```

#### **CLS Implementation** ‚ú®

```typescript
import { cls } from "@use-pico/cls";
import { useCls } from "@use-pico/cls/react";
import type { Component } from "@use-pico/cls";

// Define the CLS instance
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.bg.danger": ["bg-red-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "color.text.danger": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary", "focus:ring-blue-500"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary", "color.text.secondary", "focus:ring-gray-500"])
    }),
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger", "focus:ring-red-500"])
    })
  ],
  defaults: def.defaults({
    size: "md",
    tone: "primary"
  })
}));

// React component
interface ButtonProps extends Component<typeof ButtonCls, React.ButtonHTMLAttributes<HTMLButtonElement>> {
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary" | "danger";
}

function Button({
  children,
  size = "md",
  tone = "primary",
  tva = ButtonCls,
  cls,
  ...props
}: ButtonProps) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({
      size,
      tone
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      {children}
    </button>
  );
}
```

## **Key Differences Analysis** üîç

### **1. Architecture Philosophy** üèóÔ∏è

| Aspect | TV | CLS |
|--------|----|-----|
| **Core Approach** | Tailwind-focused variants | Contract-first design |
| **Design Philosophy** | Tailwind-first, simple | Type-safe and scalable |
| **Learning Curve** | Easy for Tailwind users | Medium learning curve |
| **Scalability** | Good for Tailwind workflows | Excellent for complex systems |

**TV**: **Tailwind-focused** - designed specifically for Tailwind CSS users with familiar patterns.

**CLS**: **Framework agnostic** - works with any CSS approach while providing comprehensive features.

### **2. Type Safety** üõ°Ô∏è

#### **TV Type Safety** üé®

```typescript
// TV provides good type safety for variants
const button = tv({
  base: "base-classes",
  variants: {
    size: { sm: "text-sm", md: "text-base", lg: "text-lg" },
    tone: { primary: "bg-blue-600", secondary: "bg-gray-600" }
  }
});

// TypeScript infers variant types
type ButtonVariants = VariantProps<typeof button>;
// Result: { size?: "sm" | "md" | "lg"; tone?: "primary" | "secondary" }
```

#### **CLS Type Safety** ‚ú®

```typescript
// CLS provides comprehensive type safety
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  // Contract validation ensures all variants are properly defined
  rules: [
    def.rule({
      variant: { size: "sm" }, // TypeScript validates this
      root: what.css(["text-sm"])
    })
  ]
}));

// Full type safety with contract validation
interface ButtonProps extends Component<typeof ButtonCls> {
  // TypeScript ensures all props match the contract
}
```

**Winner**: **CLS** - Provides **comprehensive type safety** with contract validation, while TV offers **good but limited** type safety.

### **3. Design Tokens** üé®

#### **TV Design Tokens** üé®

```typescript
// TV has no built-in design token system
const button = tv({
  base: "base-classes",
  variants: {
    size: {
      sm: "px-3 py-1.5 text-sm", // Hardcoded values
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg"
    },
    tone: {
      primary: "bg-blue-600 text-white", // Hardcoded values
      secondary: "bg-gray-600 text-white"
    }
  }
});
```

#### **CLS Design Tokens** ‚ú®

```typescript
// CLS has native design token system
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["spacing.sm"]) // Uses tokens
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"]) // Uses tokens
    })
  ]
}));
```

**Winner**: **CLS** - Provides **native design token system** with inheritance and runtime overrides, while TV requires **manual organization**.

### **4. Inheritance & Composition** üèóÔ∏è

#### **TV Inheritance** üé®

```typescript
// TV has no built-in inheritance system
const baseButton = tv({
  base: "base-classes",
  variants: { size: { sm: "text-sm", md: "text-base" } }
});

const primaryButton = tv({
  base: "base-classes",
  variants: { size: { sm: "text-sm", md: "text-base" } }
}); // Duplicate code

const dangerButton = tv({
  base: "base-classes",
  variants: { size: { sm: "text-sm", md: "text-base" } }
}); // More duplicate code
```

#### **CLS Inheritance** ‚ú®

```typescript
// CLS has multi-level inheritance
const BaseButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"] }
}, ({ what, def }) => ({
  token: def.token({
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    })
  ]
}));

// Inherit and extend
const PrimaryButtonCls = BaseButtonCls.extend({
  variant: { tone: ["primary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.text.primary": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"])
    })
  ]
}));

const DangerButtonCls = BaseButtonCls.extend({
  variant: { tone: ["danger"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.danger": ["bg-red-600"],
    "color.text.danger": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger"])
    })
  ]
}));
```

**Winner**: **CLS** - Provides **multi-level inheritance** and **composition**, while TV requires **manual code duplication**.

### **5. Runtime Flexibility** ‚ö°

#### **TV Runtime Limitations** üé®

```typescript
// TV has no runtime overrides
const button = tv({
  base: "base-classes",
  variants: {
    tone: {
      primary: "bg-blue-600",
      secondary: "bg-gray-600"
    }
  }
});

// Can't dynamically change colors at runtime
function Button({ tone, ...props }) {
  return (
    <button className={button({ tone })} {...props}>
      Click me
    </button>
  );
}
```

#### **CLS Runtime Flexibility** ‚ú®

```typescript
// CLS supports runtime overrides
const ButtonCls = cls({
  slot: ["root"],
  variant: { tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary"])
    })
  ]
}));

// Runtime override for dark theme
function Button({ tone, isDarkTheme, ...props }) {
  const buttonClasses = useCls(ButtonCls, ({ what, override }) => ({
    variant: what.variant({ tone }),
    token: override.token({
      "color.bg.primary": isDarkTheme ? ["bg-blue-800"] : ["bg-blue-600"]
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      Click me
    </button>
  );
}
```

**Winner**: **CLS** - Provides **full runtime flexibility** with token overrides, while TV is **static only**.

### **6. Tailwind CSS Integration** üé®

#### **TV Tailwind Integration** üé®

```typescript
// TV is designed specifically for Tailwind CSS
const button = tv({
  base: "inline-flex items-center justify-center rounded font-medium transition-colors",
  variants: {
    size: {
      sm: "px-3 py-1.5 text-sm", // Direct Tailwind classes
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg"
    },
    tone: {
      primary: "bg-blue-600 text-white focus:ring-blue-500", // Direct Tailwind classes
      secondary: "bg-gray-600 text-white focus:ring-gray-500"
    }
  }
});

// Seamless Tailwind integration
function Button({ size, tone, className, ...props }) {
  return (
    <button 
      className={button({ size, tone, className })} // className merges with Tailwind
      {...props}
    />
  );
}
```

#### **CLS Tailwind Integration** ‚ú®

```typescript
// CLS works with any CSS approach, including Tailwind
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"], // Tailwind classes as tokens
    "color.bg.secondary": ["bg-gray-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary", "focus:ring-blue-500"])
    })
  ]
}));

// Works with Tailwind but also other CSS approaches
function Button({ size, tone, tva = ButtonCls, cls, ...props }) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  
  return (
    <button className={buttonClasses.root()} {...props} />
  );
}
```

**Winner**: **TV** - **Optimized for Tailwind CSS** with seamless integration, while CLS is **framework agnostic**.

### **7. Bundle Size** üì¶

| Metric | TV | CLS |
|--------|----|-----|
| **Bundle Size** | ~5KB | ~15KB |
| **Runtime Overhead** | Minimal | Medium |
| **Tree Shaking** | Excellent | Good |
| **Dependencies** | Minimal | Moderate |

**Winner**: **TV** - **Smaller bundle size** and **minimal runtime overhead**.

### **8. Developer Experience** üë®‚Äçüíª

#### **TV Developer Experience** üé®

**Pros:**
- **Perfect for Tailwind users** - Familiar patterns and workflows
- **Easy to learn** - Simple API with minimal concepts
- **Quick prototyping** - Fast to get started with Tailwind
- **Good TypeScript support** - Type inference for variants
- **Seamless Tailwind integration** - No configuration needed

**Cons:**
- **Tailwind-specific** - Limited to Tailwind CSS workflows
- **Limited scalability** - No inheritance or composition
- **No design tokens** - Manual organization required
- **Static styling** - No runtime flexibility
- **Code duplication** - No way to share common patterns

#### **CLS Developer Experience** ‚ú®

**Pros:**
- **Framework agnostic** - Works with any CSS approach
- **Excellent type safety** - Contract validation and IntelliSense
- **Scalable architecture** - Inheritance and composition
- **Design token system** - Organized and reusable values
- **Runtime flexibility** - Dynamic theming and overrides
- **Predictable APIs** - Consistent patterns across components

**Cons:**
- **Learning curve** - More concepts to understand
- **Larger bundle size** - More features = more code
- **Complexity** - May be overkill for simple use cases
- **Not Tailwind-specific** - Requires more setup for Tailwind workflows

**Winner**: **Tie** - Depends on **project requirements** and **team expertise**.

## **Use Case Recommendations** üéØ

### **Choose TV When You Need:** ‚úÖ

- **Tailwind CSS workflows** with variant-based styling
- **Quick prototyping** with Tailwind CSS
- **Minimal bundle size** and runtime overhead
- **Familiar patterns** for Tailwind users
- **Simple component libraries** without complex inheritance
- **Projects where Tailwind CSS** is the primary styling approach

### **Choose CLS When You Need:** ‚úÖ

- **Framework agnostic** styling solutions
- **Type-safe design systems** with complex inheritance
- **Runtime theming** and user customization
- **Multi-framework support** across different environments
- **Design token management** with inheritance and overrides
- **Complex conditional styling** with rule-based logic
- **Team collaboration** with predictable APIs
- **Large-scale applications** with complex styling requirements

## **Migration Complexity** üõ§Ô∏è

### **From TV to CLS** üìà

**Complexity**: üü° Medium (2-4 weeks)

**Key Challenges:**
- **Learning contracts and tokens** - New concepts to understand
- **Architecture planning** - Designing inheritance hierarchy
- **Code restructuring** - Moving from variants to contracts
- **Team training** - Teaching new patterns and concepts
- **Framework agnostic approach** - Moving away from Tailwind-specific patterns

**Migration Steps:**
1. **Install CLS** and remove TV dependency
2. **Create CLS contracts** for each component
3. **Define design tokens** for consistent values
4. **Migrate component interfaces** to use `Component<T>`
5. **Replace TV calls** with `useCls()` hook
6. **Test all variant combinations** work correctly

### **From CLS to TV** üìâ

**Complexity**: üü¢ Easy (1-2 weeks)

**Key Challenges:**
- **Losing features** - No inheritance, tokens, or runtime overrides
- **Code duplication** - Manual organization of common patterns
- **Type safety reduction** - Less comprehensive type checking
- **Tailwind-specific approach** - Moving to Tailwind-only workflows

## **Performance Comparison** ‚ö°

### **Runtime Performance** üèÉ‚Äç‚ôÇÔ∏è

| Metric | TV | CLS |
|--------|----|-----|
| **Class Generation** | Fast | Fast |
| **Memory Usage** | Low | Medium |
| **Bundle Size** | Small | Medium |
| **Tree Shaking** | Excellent | Good |

**TV**: **Optimized for performance** with minimal runtime overhead.

**CLS**: **Balanced performance** with additional features and type safety.

### **Development Performance** üë®‚Äçüíª

| Metric | TV | CLS |
|--------|----|-----|
| **Learning Speed** | Fast (Tailwind users) | Medium |
| **Development Speed** | Fast (Tailwind) | Fast (complex) |
| **Refactoring Safety** | Good | Excellent |
| **Team Onboarding** | Easy (Tailwind users) | Medium |

**TV**: **Fast development** for Tailwind CSS users.

**CLS**: **Fast development** for complex systems with better safety.

## **Real-World Examples** üåç

### **Tailwind-Focused Project** üé®

**TV Example:**
```typescript
// Perfect for Tailwind-focused projects
const button = tv({
  base: "inline-flex items-center justify-center rounded font-medium transition-colors",
  variants: {
    size: { sm: "px-3 py-1.5 text-sm", md: "px-4 py-2 text-base", lg: "px-6 py-3 text-lg" },
    tone: { primary: "bg-blue-600 text-white", secondary: "bg-gray-600 text-white" }
  }
});

// Seamless Tailwind integration
function Button({ size, tone, className, ...props }) {
  return <button className={button({ size, tone, className })} {...props} />;
}
```

**CLS Example:**
```typescript
// Works with Tailwind but also other approaches
const ButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"], tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    })
  ]
}));

// More setup but framework agnostic
function Button({ size, tone, tva = ButtonCls, cls, ...props }) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

### **Multi-Framework Environment** üåê

**TV Limitations:**
```typescript
// TV is Tailwind-specific
const button = tv({
  base: "inline-flex items-center justify-center rounded font-medium transition-colors",
  variants: {
    size: { sm: "px-3 py-1.5 text-sm", md: "px-4 py-2 text-base" }
  }
});

// Only works with Tailwind CSS
// No way to use with other CSS approaches
// No design token system
// No runtime theming
```

**CLS Advantages:**
```typescript
// CLS works with any CSS approach
const ButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"] }
}, ({ what, def }) => ({
  token: def.token({
    "spacing.sm": ["px-3 py-1.5"], // Could be Tailwind, CSS Modules, or custom CSS
    "spacing.md": ["px-4 py-2"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    })
  ]
}));

// Works with Tailwind, CSS Modules, or any other approach
function Button({ size, tva = ButtonCls, cls, ...props }) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({ size })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

## **The Bottom Line** üí°

### **TV is Perfect For:** üéØ

- **Tailwind CSS projects** with variant-based styling
- **Quick prototyping** with Tailwind CSS
- **Teams using Tailwind CSS** as their primary styling approach
- **Projects where bundle size** is critical
- **Simple component libraries** without complex inheritance
- **Tailwind-focused workflows** and tooling

### **CLS is Perfect For:** üéØ

- **Framework agnostic** styling solutions
- **Complex design systems** with inheritance and composition
- **Large-scale applications** requiring type safety and scalability
- **Teams building maintainable** and extensible styling systems
- **Projects requiring runtime theming** and user customization
- **Multi-framework environments** where consistency is crucial

### **The Choice Depends On:** ü§î

- **CSS approach** (Tailwind vs. other approaches)
- **Project complexity** and scale
- **Team expertise** and learning capacity
- **Performance requirements** and constraints
- **Long-term maintainability** goals
- **Framework flexibility** requirements

**TV** is the **Tailwind-optimized solution** for Tailwind CSS workflows.

**CLS** is the **framework-agnostic solution** for complex design systems.

Choose the tool that matches your **CSS approach** and **project requirements**! üöÄ

---

**[‚Üê Previous: vs CVA](./13.4-vs-cva-class-variance-authority.md)** | **[‚Üí Next: vs Stitches](./13.6-vs-stitches.md)**
