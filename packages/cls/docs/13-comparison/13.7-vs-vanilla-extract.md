# 13.7 vs Vanilla Extract

## Table of Contents
- [13.1 Feature Table](./13.1-feature-table.md)
- [13.2 Code Comparisons](./13.2-code-comparisons.md)
- [13.3 Migration Paths](./13.3-migration-paths.md)
- [13.4 vs CVA (Class Variance Authority)](./13.4-vs-cva-class-variance-authority.md)
- [13.5 vs TV (Tailwind Variants)](./13.5-vs-tv-tailwind-variants.md)
- [13.6 vs Stitches](./13.6-vs-stitches.md)
- [13.7 vs Vanilla Extract](./13.7-vs-vanilla-extract.md) *(current)*

---

This chapter provides a **detailed comparison** between CLS and **Vanilla Extract**, a popular zero-runtime CSS-in-JS library with type safety. We'll explore their **similarities**, **differences**, and **when to choose each**.

## **What is Vanilla Extract?** ü§î

**Vanilla Extract** is a popular **zero-runtime CSS-in-JS** library that provides **type-safe CSS** with **compile-time CSS generation**. It's designed to work with **build tools** and provides excellent **TypeScript integration** without runtime overhead.

### **Vanilla Extract's Core Philosophy** üéØ

- **Zero-runtime CSS-in-JS** - Generate CSS at build time, not runtime
- **Type-safe CSS** - Full TypeScript support for CSS properties
- **Build-time optimization** - CSS generation during build process
- **Design token system** - Native support for design tokens and themes
- **Framework agnostic** - Works with any framework or build tool

## **Side-by-Side Comparison** üìä

### **Basic Button Component** üéØ

Let's compare how both libraries handle a simple button component with size and tone variants.

#### **Vanilla Extract Implementation** üç¶

```typescript
import { style, styleVariants } from "@vanilla-extract/css";
import { recipe } from "@vanilla-extract/recipes";

const base = style({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "0.375rem",
  fontWeight: "500",
  transition: "colors",
  outline: "none",
  cursor: "pointer",
  
  ":focus": {
    boxShadow: "0 0 0 2px #3b82f6, 0 0 0 4px #ffffff",
  },
  
  ":disabled": {
    opacity: 0.5,
    cursor: "not-allowed",
  },
});

const sizes = styleVariants({
  sm: {
    padding: "0.375rem 0.75rem",
    fontSize: "0.875rem",
  },
  md: {
    padding: "0.5rem 1rem",
    fontSize: "1rem",
  },
  lg: {
    padding: "0.75rem 1.5rem",
    fontSize: "1.125rem",
  },
});

const tones = styleVariants({
  primary: {
    backgroundColor: "#2563eb",
    color: "#ffffff",
    ":focus": {
      boxShadow: "0 0 0 2px #3b82f6, 0 0 0 4px #ffffff",
    },
  },
  secondary: {
    backgroundColor: "#4b5563",
    color: "#ffffff",
    ":focus": {
      boxShadow: "0 0 0 2px #6b7280, 0 0 0 4px #ffffff",
    },
  },
  danger: {
    backgroundColor: "#dc2626",
    color: "#ffffff",
    ":focus": {
      boxShadow: "0 0 0 2px #ef4444, 0 0 0 4px #ffffff",
    },
  },
});

const buttonRecipe = recipe({
  base,
  variants: {
    size: sizes,
    tone: tones,
  },
  defaultVariants: {
    size: "md",
    tone: "primary",
  },
});

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  size?: keyof typeof sizes;
  tone?: keyof typeof tones;
}

function Button({
  children,
  size = "md",
  tone = "primary",
  className,
  ...props
}: ButtonProps) {
  return (
    <button
      className={buttonRecipe({ size, tone, className })}
      {...props}
    >
      {children}
    </button>
  );
}
```

#### **CLS Implementation** ‚ú®

```typescript
import { cls } from "@use-pico/cls";
import { useCls } from "@use-pico/cls/react";
import type { Component } from "@use-pico/cls";

// Define the CLS instance
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.bg.danger": ["bg-red-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "color.text.danger": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors",
        "outline-none cursor-pointer",
        "focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
        "disabled:opacity-50 disabled:cursor-not-allowed"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary", "focus:ring-blue-500"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary", "color.text.secondary", "focus:ring-gray-500"])
    }),
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger", "focus:ring-red-500"])
    })
  ],
  defaults: def.defaults({
    size: "md",
    tone: "primary"
  })
}));

// React component
interface ButtonProps extends Component<typeof ButtonCls, React.ButtonHTMLAttributes<HTMLButtonElement>> {
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary" | "danger";
}

function Button({
  children,
  size = "md",
  tone = "primary",
  tva = ButtonCls,
  cls,
  ...props
}: ButtonProps) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({
      size,
      tone
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      {children}
    </button>
  );
}
```

## **Key Differences Analysis** üîç

### **1. Architecture Philosophy** üèóÔ∏è

| Aspect | Vanilla Extract | CLS |
|--------|-----------------|-----|
| **Core Approach** | Build-time CSS generation | Runtime class-based styling |
| **Design Philosophy** | Zero-runtime CSS-in-JS | Type-safe and scalable class-based system |
| **Learning Curve** | Medium (build tool integration) | Medium (contract and token concepts) |
| **Scalability** | Good for build-time workflows | Excellent for complex systems |

**Vanilla Extract**: **Build-time focused** - generates CSS at build time with zero runtime overhead.

**CLS**: **Runtime focused** - provides type-safe styling with utility classes and design tokens.

### **2. Type Safety** üõ°Ô∏è

#### **Vanilla Extract Type Safety** üç¶

```typescript
// Vanilla Extract provides excellent type safety
const sizes = styleVariants({
  sm: { padding: "0.375rem 0.75rem", fontSize: "0.875rem" },
  md: { padding: "0.5rem 1rem", fontSize: "1rem" },
  lg: { padding: "0.75rem 1.5rem", fontSize: "1.125rem" }
});

const tones = styleVariants({
  primary: { backgroundColor: "#2563eb", color: "#ffffff" },
  secondary: { backgroundColor: "#4b5563", color: "#ffffff" }
});

// TypeScript infers variant types
type ButtonVariants = {
  size?: keyof typeof sizes;
  tone?: keyof typeof tones;
};
// Result: { size?: "sm" | "md" | "lg"; tone?: "primary" | "secondary" }
```

#### **CLS Type Safety** ‚ú®

```typescript
// CLS provides comprehensive type safety
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  // Contract validation ensures all variants are properly defined
  rules: [
    def.rule({
      variant: { size: "sm" }, // TypeScript validates this
      root: what.css(["text-sm"])
    })
  ]
}));

// Full type safety with contract validation
interface ButtonProps extends Component<typeof ButtonCls> {
  // TypeScript ensures all props match the contract
}
```

**Winner**: **Tie** - Both provide **excellent type safety**, but with different approaches.

### **3. Design Tokens** üé®

#### **Vanilla Extract Design Tokens** üç¶

```typescript
// Vanilla Extract has native design token system
import { createGlobalTheme } from "@vanilla-extract/css";

const theme = createGlobalTheme(":root", {
  colors: {
    blue600: "#2563eb",
    gray600: "#4b5563",
    red600: "#dc2626",
    white: "#ffffff"
  },
  spacing: {
    sm: "0.375rem 0.75rem",
    md: "0.5rem 1rem",
    lg: "0.75rem 1.5rem"
  },
  fontSize: {
    sm: "0.875rem",
    base: "1rem",
    lg: "1.125rem"
  }
});

const sizes = styleVariants({
  sm: {
    padding: theme.spacing.sm,
    fontSize: theme.fontSize.sm
  },
  md: {
    padding: theme.spacing.md,
    fontSize: theme.fontSize.base
  },
  lg: {
    padding: theme.spacing.lg,
    fontSize: theme.fontSize.lg
  }
});
```

#### **CLS Design Tokens** ‚ú®

```typescript
// CLS has native design token system
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["spacing.sm"]) // Uses tokens
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"]) // Uses tokens
    })
  ]
}));
```

**Winner**: **Tie** - Both provide **native design token systems**, but with different approaches.

### **4. Inheritance & Composition** üèóÔ∏è

#### **Vanilla Extract Inheritance** üç¶

```typescript
// Vanilla Extract has limited inheritance through composition
const base = style({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "0.375rem",
  fontWeight: "500",
  transition: "colors",
  outline: "none",
  cursor: "pointer",
});

const primaryButton = style([
  base,
  {
    backgroundColor: "#2563eb",
    color: "#ffffff",
    ":focus": {
      boxShadow: "0 0 0 2px #3b82f6, 0 0 0 4px #ffffff",
    },
  }
]);

const dangerButton = style([
  base,
  {
    backgroundColor: "#dc2626",
    color: "#ffffff",
    ":focus": {
      boxShadow: "0 0 0 2px #ef4444, 0 0 0 4px #ffffff",
    },
  }
]);
```

#### **CLS Inheritance** ‚ú®

```typescript
// CLS has multi-level inheritance
const BaseButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"] }
}, ({ what, def }) => ({
  token: def.token({
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    })
  ]
}));

// Inherit and extend
const PrimaryButtonCls = BaseButtonCls.extend({
  variant: { tone: ["primary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.text.primary": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"])
    })
  ]
}));

const DangerButtonCls = BaseButtonCls.extend({
  variant: { tone: ["danger"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.danger": ["bg-red-600"],
    "color.text.danger": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger"])
    })
  ]
}));
```

**Winner**: **CLS** - Provides **multi-level inheritance** and **composition**, while Vanilla Extract has **limited inheritance** through composition.

### **5. Runtime Flexibility** ‚ö°

#### **Vanilla Extract Runtime Limitations** üç¶

```typescript
// Vanilla Extract has no runtime overrides (build-time only)
const buttonRecipe = recipe({
  base,
  variants: {
    size: sizes,
    tone: tones,
  },
  defaultVariants: {
    size: "md",
    tone: "primary",
  },
});

// Can't dynamically change styles at runtime
function Button({ size, tone, ...props }) {
  return (
    <button className={buttonRecipe({ size, tone })} {...props}>
      Click me
    </button>
  );
}
```

#### **CLS Runtime Flexibility** ‚ú®

```typescript
// CLS supports runtime overrides
const ButtonCls = cls({
  slot: ["root"],
  variant: { tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary"])
    })
  ]
}));

// Runtime override for dark theme
function Button({ tone, isDarkTheme, ...props }) {
  const buttonClasses = useCls(ButtonCls, ({ what, override }) => ({
    variant: what.variant({ tone }),
    token: override.token({
      "color.bg.primary": isDarkTheme ? ["bg-blue-800"] : ["bg-blue-600"]
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      Click me
    </button>
  );
}
```

**Winner**: **CLS** - Provides **full runtime flexibility** with token overrides, while Vanilla Extract is **build-time only**.

### **6. Build-time vs Runtime** üèóÔ∏è

#### **Vanilla Extract Build-time Approach** üç¶

```typescript
// Vanilla Extract generates CSS at build time
const buttonStyle = style({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: "0.375rem",
  fontWeight: "500",
  transition: "colors",
  outline: "none",
  cursor: "pointer",
  
  ":focus": {
    boxShadow: "0 0 0 2px #3b82f6, 0 0 0 4px #ffffff",
  },
  
  ":disabled": {
    opacity: 0.5,
    cursor: "not-allowed",
  },
});

// CSS is generated during build process
// No runtime CSS generation or injection
// Zero runtime overhead
```

#### **CLS Runtime Approach** ‚ú®

```typescript
// CLS generates classes at runtime
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors",
        "outline-none cursor-pointer",
        "focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
        "disabled:opacity-50 disabled:cursor-not-allowed"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "px-3 py-1.5"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "text-white"])
    })
  ]
}));

// Classes are generated at runtime
// Dynamic styling and theming
// Runtime flexibility
```

**Winner**: **Tie** - Depends on **preferred approach** (build-time vs runtime).

### **7. Bundle Size** üì¶

| Metric | Vanilla Extract | CLS |
|--------|-----------------|-----|
| **Bundle Size** | ~5KB | ~15KB |
| **Runtime Overhead** | Zero | Medium |
| **Tree Shaking** | Excellent | Good |
| **Dependencies** | Minimal | Moderate |

**Winner**: **Vanilla Extract** - **Smaller bundle size** and **zero runtime overhead**.

### **8. Developer Experience** üë®‚Äçüíª

#### **Vanilla Extract Developer Experience** üç¶

**Pros:**
- **Zero runtime overhead** - No CSS generation at runtime
- **Excellent type safety** - Full TypeScript support for CSS
- **Build-time optimization** - CSS generation during build
- **Design token support** - Native design token system
- **Framework agnostic** - Works with any build tool

**Cons:**
- **Build tool dependency** - Requires specific build tool integration
- **No runtime flexibility** - Can't change styles dynamically
- **Learning curve** - Build tool integration and concepts
- **Limited inheritance** - Basic composition only
- **No dynamic theming** - Static CSS generation

#### **CLS Developer Experience** ‚ú®

**Pros:**
- **Framework agnostic** - Works with any framework or no framework
- **Excellent type safety** - Contract validation and IntelliSense
- **Scalable architecture** - Inheritance and composition
- **Design token system** - Organized and reusable values
- **Runtime flexibility** - Dynamic theming and overrides
- **Predictable APIs** - Consistent patterns across components

**Cons:**
- **Learning curve** - More concepts to understand
- **Runtime overhead** - Class generation at runtime
- **Complexity** - May be overkill for simple use cases
- **Utility class dependency** - Requires utility-first CSS approach

**Winner**: **Tie** - Depends on **preferred approach** and **project requirements**.

## **Use Case Recommendations** üéØ

### **Choose Vanilla Extract When You Need:** ‚úÖ

- **Zero runtime overhead** with build-time CSS generation
- **Type-safe CSS** with full TypeScript support
- **Build-time optimization** and tree-shaking
- **Design token system** with static CSS generation
- **Projects where performance** is critical
- **Static styling** without runtime theming

### **Choose CLS When You Need:** ‚úÖ

- **Runtime flexibility** and dynamic theming
- **Framework agnostic** styling solutions
- **Type-safe design systems** with complex inheritance
- **Runtime theming** and user customization
- **Multi-framework support** across different environments
- **Design token management** with inheritance and overrides
- **Complex conditional styling** with rule-based logic
- **Team collaboration** with predictable APIs

## **Migration Complexity** üõ§Ô∏è

### **From Vanilla Extract to CLS** üìà

**Complexity**: üî¥ High (4-8 weeks)

**Key Challenges:**
- **Moving from build-time to runtime** - Different styling paradigm
- **Learning contracts and tokens** - New concepts to understand
- **Architecture planning** - Designing inheritance hierarchy
- **Code restructuring** - Converting build-time styles to runtime classes
- **Team training** - Teaching new patterns and concepts
- **Build tool changes** - Removing Vanilla Extract integration

**Migration Steps:**
1. **Install CLS** and remove Vanilla Extract dependency
2. **Create CLS contracts** for each component
3. **Convert build-time styles** to runtime classes
4. **Define design tokens** for consistent values
5. **Migrate component interfaces** to use `Component<T>`
6. **Replace recipe calls** with `useCls()` hook
7. **Test all variant combinations** work correctly
8. **Update build configuration** to remove Vanilla Extract

### **From CLS to Vanilla Extract** üìâ

**Complexity**: üî¥ High (4-8 weeks)

**Key Challenges:**
- **Moving from runtime to build-time** - Different styling paradigm
- **Losing features** - No inheritance, no runtime overrides
- **Code restructuring** - Converting runtime classes to build-time styles
- **Build tool integration** - Setting up Vanilla Extract
- **Performance trade-offs** - Zero runtime vs runtime flexibility

## **Performance Comparison** ‚ö°

### **Runtime Performance** üèÉ‚Äç‚ôÇÔ∏è

| Metric | Vanilla Extract | CLS |
|--------|-----------------|-----|
| **CSS Generation** | Build-time | Runtime |
| **Memory Usage** | Low | Medium |
| **Bundle Size** | Small | Medium |
| **Tree Shaking** | Excellent | Good |

**Vanilla Extract**: **Zero runtime overhead** with build-time CSS generation.

**CLS**: **Runtime overhead** with class generation and styling logic.

### **Development Performance** üë®‚Äçüíª

| Metric | Vanilla Extract | CLS |
|--------|-----------------|-----|
| **Learning Speed** | Medium | Medium |
| **Development Speed** | Fast (build-time) | Fast (runtime) |
| **Refactoring Safety** | Good | Excellent |
| **Team Onboarding** | Medium | Medium |

**Vanilla Extract**: **Fast development** for build-time workflows.

**CLS**: **Fast development** for runtime workflows with better safety.

## **Real-World Examples** üåç

### **Performance-Critical Project** ‚ö°

**Vanilla Extract Example:**
```typescript
// Perfect for performance-critical projects
const buttonRecipe = recipe({
  base: style({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: "0.375rem",
    fontWeight: "500",
    transition: "colors",
    outline: "none",
    cursor: "pointer",
  }),
  variants: {
    size: {
      sm: { padding: "0.375rem 0.75rem", fontSize: "0.875rem" },
      md: { padding: "0.5rem 1rem", fontSize: "1rem" },
      lg: { padding: "0.75rem 1.5rem", fontSize: "1.125rem" }
    },
    tone: {
      primary: { backgroundColor: "#2563eb", color: "#ffffff" },
      secondary: { backgroundColor: "#4b5563", color: "#ffffff" }
    }
  },
  defaultVariants: {
    size: "md",
    tone: "primary"
  }
});

// Zero runtime overhead
function Button({ size, tone, ...props }) {
  return <button className={buttonRecipe({ size, tone })} {...props} />;
}
```

**CLS Example:**
```typescript
// Works with runtime flexibility
const ButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"], tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors",
        "outline-none cursor-pointer"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "px-3 py-1.5"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "text-white"])
    })
  ]
}));

// Runtime overhead but more flexibility
function Button({ size, tone, tva = ButtonCls, cls, ...props }) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

### **Dynamic Theming Project** üé®

**Vanilla Extract Limitations:**
```typescript
// Vanilla Extract is build-time only
const buttonRecipe = recipe({
  base: style({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: "0.375rem",
    fontWeight: "500",
    transition: "colors",
    outline: "none",
    cursor: "pointer",
  }),
  variants: {
    tone: {
      primary: { backgroundColor: "#2563eb", color: "#ffffff" },
      secondary: { backgroundColor: "#4b5563", color: "#ffffff" }
    }
  }
});

// No way to change colors at runtime
// No dynamic theming
// No user customization
function Button({ tone, ...props }) {
  return <button className={buttonRecipe({ tone })} {...props} />;
}
```

**CLS Advantages:**
```typescript
// CLS supports runtime theming
const ButtonCls = cls({
  slot: ["root"],
  variant: { tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary"])
    })
  ]
}));

// Runtime theming and user customization
function Button({ tone, theme, ...props }) {
  const buttonClasses = useCls(ButtonCls, ({ what, override }) => ({
    variant: what.variant({ tone }),
    token: override.token({
      "color.bg.primary": theme === "dark" ? ["bg-blue-800"] : ["bg-blue-600"]
    })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

## **The Bottom Line** üí°

### **Vanilla Extract is Perfect For:** üéØ

- **Performance-critical projects** with zero runtime overhead
- **Build-time optimization** and tree-shaking
- **Type-safe CSS** with full TypeScript support
- **Static styling** without runtime theming
- **Projects where bundle size** is critical
- **Build-time focused workflows**

### **CLS is Perfect For:** üéØ

- **Runtime flexibility** and dynamic theming
- **Framework agnostic** styling solutions
- **Complex design systems** with inheritance and composition
- **Large-scale applications** requiring type safety and scalability
- **Teams building maintainable** and extensible styling systems
- **Projects requiring runtime theming** and user customization
- **Multi-framework environments** where consistency is crucial

### **The Choice Depends On:** ü§î

- **Performance requirements** (zero runtime vs runtime flexibility)
- **Styling approach** (build-time vs runtime)
- **Project complexity** and scale
- **Team expertise** and learning capacity
- **Theming requirements** (static vs dynamic)
- **Long-term maintainability** goals

**Vanilla Extract** is the **zero-runtime solution** for performance-critical projects.

**CLS** is the **runtime-flexible solution** for complex design systems.

Choose the tool that matches your **performance requirements** and **project needs**! üöÄ

---

**[‚Üê Previous: vs Stitches](./13.6-vs-stitches.md)** | **[‚Üí Next Chapter: Migration Guide](./../14-migration-guide/README.md)**
