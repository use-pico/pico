# 4.7 Theming & Tokens

This chapter explores **advanced theming patterns** in CLS, focusing on how to create flexible, dynamic theming systems using React context and token overrides. You'll learn how to build themeable applications that can adapt to different contexts and user preferences.

## üéØ What is Theming & Tokens?

Theming in CLS involves:
- **Token-based design systems** with semantic naming
- **Context-driven theme inheritance** through React Context
- **Runtime token overrides** for dynamic theming
- **Theme switching** and customization
- **Multi-level theme composition**

Think of it as **dynamic styling infrastructure** that adapts to different contexts and user preferences.

## üìù Basic Theming Setup

```tsx
import { cls } from "@use-pico/cls";
import { ClsProvider, useCls } from "@use-pico/cls/react";

// Define semantic tokens
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      surface: ["bg-white"],
      overlay: ["bg-black bg-opacity-50"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      onPrimary: ["text-white"],
      onSurface: ["text-gray-900"]
    },
    "spacing": {
      xs: ["p-1"],
      sm: ["p-2"],
      md: ["p-4"],
      lg: ["p-6"],
      xl: ["p-8"]
    },
    "border.radius": {
      sm: ["rounded"],
      md: ["rounded-md"],
      lg: ["rounded-lg"],
      full: ["rounded-full"]
    }
  }
});

// Component that uses theme tokens
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  root: def.root([
    "inline-flex items-center justify-center font-medium transition-colors",
    what.variant({ size: "md", tone: "primary" })
  ])
}));

function Button({ 
  children, 
  size = "md", 
  tone = "primary" 
}: { 
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary";
}) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  
  return <button className={buttonClasses.root()}>{children}</button>;
}

// Theme provider
function App() {
  return (
    <ClsProvider value={ThemeCls}>
      <div className="min-h-screen bg-gray-50">
        <Button size="lg" tone="primary">Themed Button</Button>
      </div>
    </ClsProvider>
  );
}
```

## üé® Advanced Theming Patterns

### **Multi-Theme System**

Create a system that supports multiple themes:

```tsx
// Light theme
const LightThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      surface: ["bg-white"],
      overlay: ["bg-black bg-opacity-50"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      onPrimary: ["text-white"],
      onSurface: ["text-gray-900"]
    }
  }
});

// Dark theme
const DarkThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-500"],
      secondary: ["bg-gray-700"],
      surface: ["bg-gray-900"],
      overlay: ["bg-black bg-opacity-75"]
    },
    "color.text": {
      primary: ["text-blue-400"],
      secondary: ["text-gray-400"],
      onPrimary: ["text-white"],
      onSurface: ["text-gray-100"]
    }
  }
});

// Theme provider with switching
function ThemeProvider({ 
  children, 
  theme 
}: { 
  children: React.ReactNode;
  theme: "light" | "dark";
}) {
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      {children}
    </ClsProvider>
  );
}

// Usage
function App() {
  const [theme, setTheme] = useState<"light" | "dark">("light");
  
  return (
    <ThemeProvider theme={theme}>
      <div className="min-h-screen bg-surface text-onSurface">
        <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
          Switch to {theme === "light" ? "Dark" : "Light"} Theme
        </button>
        <Button tone="primary">Themed Button</Button>
      </div>
    </ThemeProvider>
  );
}
```

### **Component-Specific Theming**

Override themes for specific components or sections:

```tsx
// Global theme
const GlobalThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    }
  }
});

// Button-specific theme
const ButtonThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-green-600"], // Overrides global primary
      danger: ["bg-red-600"]     // New token for buttons
    }
  }
});

// Card-specific theme
const CardThemeCls = cls({
  token: {
    "color.bg": {
      surface: ["bg-white"],
      elevated: ["bg-gray-50"]
    },
    "border.radius": {
      card: ["rounded-lg"]
    }
  }
});

function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      
      <ClsProvider value={ButtonThemeCls}>
        <ButtonSection>
          <Button tone="primary">Green Primary</Button>
          <Button tone="danger">Red Danger</Button>
        </ButtonSection>
      </ClsProvider>
      
      <ClsProvider value={CardThemeCls}>
        <CardSection>
          <Card>Uses card theme</Card>
        </CardSection>
      </ClsProvider>
    </ClsProvider>
  );
}
```

### **Runtime Token Overrides**

Dynamically override tokens at runtime:

```tsx
function DynamicThemeProvider({ 
  children, 
  overrides 
}: { 
  children: React.ReactNode;
  overrides?: Record<string, Record<string, string[]>>;
}) {
  const baseThemeCls = useClsContext();
  
  if (!baseThemeCls || !overrides) {
    return <>{children}</>;
  }
  
  // Create a new CLS instance with runtime overrides
  const dynamicThemeCls = baseThemeCls.extend({
    token: overrides
  });
  
  return (
    <ClsProvider value={dynamicThemeCls}>
      {children}
    </ClsProvider>
  );
}

// Usage
function App() {
  const [customColors, setCustomColors] = useState({
    "color.bg": {
      primary: ["bg-purple-600"]
    }
  });
  
  return (
    <ClsProvider value={ThemeCls}>
      <DynamicThemeProvider overrides={customColors}>
        <Button tone="primary">Purple Primary</Button>
      </DynamicThemeProvider>
    </ClsProvider>
  );
}
```

## üîß Token Composition Patterns

### **Token Inheritance**

Create token hierarchies that inherit and override:

```tsx
// Base tokens
const BaseTokensCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    },
    "spacing": {
      sm: ["p-2"],
      md: ["p-4"],
      lg: ["p-6"]
    }
  }
});

// Brand-specific tokens
const BrandTokensCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-green-600"], // Overrides base primary
      accent: ["bg-orange-500"]  // New brand color
    }
  }
});

// Component-specific tokens
const ComponentTokensCls = cls({
  token: {
    "spacing": {
      button: ["px-4 py-2"], // Component-specific spacing
      card: ["p-6"]          // Component-specific spacing
    }
  }
});

// Compose all tokens
const AppThemeCls = BaseTokensCls
  .use(BrandTokensCls)
  .use(ComponentTokensCls);
```

### **Semantic Token Mapping**

Map semantic tokens to design tokens:

```tsx
// Design tokens (raw values)
const DesignTokensCls = cls({
  token: {
    "color": {
      blue: {
        50: ["#eff6ff"],
        500: ["#3b82f6"],
        600: ["#2563eb"],
        700: ["#1d4ed8"]
      },
      gray: {
        50: ["#f9fafb"],
        500: ["#6b7280"],
        600: ["#4b5563"],
        700: ["#374151"]
      }
    }
  }
});

// Semantic tokens (meaningful names)
const SemanticTokensCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      surface: ["bg-gray-50"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      onSurface: ["text-gray-900"]
    }
  }
});

// Compose design and semantic tokens
const ThemeCls = DesignTokensCls.use(SemanticTokensCls);
```

## üéØ Advanced Theming Features

### **Theme Switching with Persistence**

```tsx
function ThemeSwitcher() {
  const [theme, setTheme] = useState<"light" | "dark">(() => {
    // Load theme from localStorage
    const saved = localStorage.getItem("theme");
    return (saved as "light" | "dark") || "light";
  });
  
  useEffect(() => {
    // Save theme to localStorage
    localStorage.setItem("theme", theme);
    
    // Apply theme to document
    document.documentElement.setAttribute("data-theme", theme);
  }, [theme]);
  
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <div className="min-h-screen bg-surface text-onSurface">
        <button 
          onClick={() => setTheme(theme === "light" ? "dark" : "light")}
          className="fixed top-4 right-4 p-2 bg-primary text-onPrimary rounded"
        >
          {theme === "light" ? "üåô" : "‚òÄÔ∏è"}
        </button>
        <ThemedContent />
      </div>
    </ClsProvider>
  );
}
```

### **Responsive Theming**

Adapt themes based on screen size or other conditions:

```tsx
function ResponsiveThemeProvider({ children }: { children: React.ReactNode }) {
  const [isMobile, setIsMobile] = useState(false);
  
  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  
  // Mobile-specific theme adjustments
  const mobileOverrides = isMobile ? {
    "spacing": {
      sm: ["p-1"],
      md: ["p-2"],
      lg: ["p-4"]
    },
    "border.radius": {
      sm: ["rounded-sm"],
      md: ["rounded"],
      lg: ["rounded-md"]
    }
  } : {};
  
  const responsiveThemeCls = ThemeCls.extend({
    token: mobileOverrides
  });
  
  return (
    <ClsProvider value={responsiveThemeCls}>
      {children}
    </ClsProvider>
  );
}
```

### **User Preference Theming**

Respect user's system preferences:

```tsx
function SystemThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<"light" | "dark">("light");
  
  useEffect(() => {
    // Check system preference
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = (e: MediaQueryListEvent) => {
      setTheme(e.matches ? "dark" : "light");
    };
    
    setTheme(mediaQuery.matches ? "dark" : "light");
    mediaQuery.addEventListener("change", handleChange);
    
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);
  
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      {children}
    </ClsProvider>
  );
}
```

## üîç Best Practices

### **1. Semantic Token Naming**

```tsx
// ‚úÖ Good: Semantic naming
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      surface: ["bg-white"],
      overlay: ["bg-black bg-opacity-50"]
    }
  }
});

// ‚ùå Avoid: Non-semantic naming
const ThemeCls = cls({
  token: {
    "color.bg": {
      blue600: ["bg-blue-600"],
      white: ["bg-white"],
      black50: ["bg-black bg-opacity-50"]
    }
  }
});
```

### **2. Token Hierarchy**

```tsx
// ‚úÖ Good: Clear token hierarchy
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"]
    }
  }
});

// ‚ùå Avoid: Flat token structure
const ThemeCls = cls({
  token: {
    "bgPrimary": ["bg-blue-600"],
    "bgSecondary": ["bg-gray-600"],
    "textPrimary": ["text-blue-600"],
    "textSecondary": ["text-gray-600"]
  }
});
```

### **3. Theme Composition**

```tsx
// ‚úÖ Good: Composable themes
const AppThemeCls = BaseThemeCls
  .use(BrandThemeCls)
  .use(ComponentThemeCls);

// ‚ùå Avoid: Monolithic themes
const AppThemeCls = cls({
  token: {
    // All tokens in one place - hard to maintain
  }
});
```

## üöÄ What's Next?

Now that you understand Theming & Tokens, you're ready to explore:

- **[Chapter 5: Tokens](../05-tokens/README.md)**: Deep dive into token system
- **[Chapter 6: Slots](../06-slots/README.md)**: Mastering component slots
- **[Chapter 7: Variants](../07-variants/README.md)**: Advanced variant patterns

Theming & Tokens are the foundation for building flexible, adaptive applications with CLS. Use these patterns to create dynamic, user-friendly theming systems! üéâ

## Table of Contents
- [4.1 `useCls` Hook](./4.1-usecls-hook.md)
- [4.2 `withCls` HOC](./4.2-withcls-hoc.md)
- [4.3 Context Integration](./4.3-context-integration.md)
- [4.4 `Component` Patterns](./4.4-component-patterns.md)
- [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)
- [4.6 Component Creation](./4.6-component-creation.md)
- [4.7 Theming & Tokens](./4.7-theming-tokens.md) *(current)*

---

**Previous:** [4.6 Component Creation](./4.6-component-creation.md) | **Next:** [Chapter 5: Tokens](../05-tokens/README.md)
