# 4.4 `Component` Patterns

## Table of Contents
- [4.1 `useCls` Hook](./4.1-usecls-hook.md)
- [4.2 `withCls` HOC](./4.2-withcls-hoc.md)
- [4.3 Context Integration](./4.3-context-integration.md)
- [4.4 `Component` Patterns](./4.4-component-patterns.md) *(current)*
- [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)
- [4.6 Component Creation](./4.6-component-creation.md)
- [4.7 Theming & Tokens](./4.7-theming-tokens.md)

---

CLS provides powerful patterns for building **reusable, composable React components** that are type-safe, maintainable, and highly flexible. This chapter explores advanced patterns that leverage CLS's strengths for component architecture.

## üéØ What are Component Patterns?

Component Patterns in CLS are architectural approaches that help you:
- **Build reusable components** with consistent APIs
- **Compose complex UIs** from simple building blocks
- **Maintain type safety** across component boundaries
- **Create flexible styling systems** that adapt to different contexts

Think of them as **blueprints** for building robust, scalable component libraries.

## üìù Basic Component Pattern

```tsx
import { cls } from "@use-pico/cls";
import { useCls } from "@use-pico/cls/react";

// Define the component's styling contract
const ButtonCls = cls({
  slot: ["root", "label", "icon"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger"],
    disabled: [true, false]
  }
}, ({ what, def }) => ({
  root: def.root([
    "inline-flex items-center justify-center rounded font-medium transition-colors",
    what.variant({ size: "md", tone: "primary", disabled: false })
  ]),
  label: def.label(["text-white"]),
  icon: def.icon(["w-4 h-4"])
}));

// Define the component's props interface
interface ButtonProps {
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary" | "danger";
  disabled?: boolean;
  icon?: React.ReactNode;
  onClick?: () => void;
}

// Implement the component
function Button({ 
  children, 
  size = "md", 
  tone = "primary", 
  disabled = false,
  icon,
  onClick,
  ...props 
}: ButtonProps) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone, disabled })
  }));
  
  return (
    <button 
      className={buttonClasses.root()}
      disabled={disabled}
      onClick={onClick}
      {...props}
    >
      {icon && <span className={buttonClasses.icon()}>{icon}</span>}
      <span className={buttonClasses.label()}>{children}</span>
    </button>
  );
}

export { Button, ButtonCls };
```

## üé® Advanced Component Patterns

### **Compound Component Pattern**

Create components that work together as a unit:

```tsx
const CardCls = cls({
  slot: ["root", "header", "body", "footer"],
  variant: {
    size: ["sm", "md", "lg"],
    layout: ["horizontal", "vertical"]
  }
}, ({ what, def }) => ({
  root: def.root([
    "border rounded-lg shadow-sm",
    what.variant({ size: "md", layout: "vertical" })
  ]),
  header: def.header(["p-4 border-b"]),
  body: def.body(["p-4"]),
  footer: def.footer(["p-4 border-t bg-gray-50"])
}));

interface CardProps {
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  layout?: "horizontal" | "vertical";
}

function Card({ children, size = "md", layout = "vertical", ...props }: CardProps) {
  const cardClasses = useCls(CardCls, ({ what }) => ({
    variant: what.variant({ size, layout })
  }));
  
  return <div className={cardClasses.root()} {...props}>{children}</div>;
}

// Compound components
function CardHeader({ children, ...props }: { children: React.ReactNode }) {
  const cardClasses = useCls(CardCls);
  return <div className={cardClasses.header()} {...props}>{children}</div>;
}

function CardBody({ children, ...props }: { children: React.ReactNode }) {
  const cardClasses = useCls(CardCls);
  return <div className={cardClasses.body()} {...props}>{children}</div>;
}

function CardFooter({ children, ...props }: { children: React.ReactNode }) {
  const cardClasses = useCls(CardCls);
  return <div className={cardClasses.footer()} {...props}>{children}</div>;
}

// Usage
function App() {
  return (
    <Card size="lg" layout="horizontal">
      <CardHeader>Title</CardHeader>
      <CardBody>Content goes here</CardBody>
      <CardFooter>Actions</CardFooter>
    </Card>
  );
}
```

### **Render Prop Pattern**

Create flexible components that accept custom render functions:

```tsx
interface RenderProps<T> {
  children: (props: T) => React.ReactNode;
}

function StyledContainer<T extends object>({ 
  children, 
  ...props 
}: RenderProps<T> & T) {
  const containerClasses = useCls(ContainerCls);
  
  return (
    <div className={containerClasses.root()}>
      {children(props as T)}
    </div>
  );
}

// Usage
function App() {
  return (
    <StyledContainer theme="dark" size="lg">
      {({ theme, size }) => (
        <div>Rendered with {theme} theme and {size} size</div>
      )}
    </StyledContainer>
  );
}
```

### **Higher-Order Component Pattern**

Enhance components with CLS functionality:

```tsx
function withStyling<T extends object>(
  Component: React.ComponentType<T>,
  clsInstance: Cls<any>
) {
  return function StyledComponent(props: T) {
    const classes = useCls(clsInstance);
    
    return (
      <div className={classes.root()}>
        <Component {...props} />
      </div>
    );
  };
}

// Usage
const StyledButton = withStyling(Button, ButtonWrapperCls);
```

## üîß Component Composition Patterns

### **Slot-Based Composition**

Use CLS slots for flexible component composition:

```tsx
const ModalCls = cls({
  slot: ["overlay", "container", "header", "body", "footer", "closeButton"],
  variant: {
    size: ["sm", "md", "lg"],
    position: ["center", "top", "bottom"]
  }
}, ({ what, def }) => ({
  overlay: def.overlay(["fixed inset-0 bg-black bg-opacity-50"]),
  container: def.container([
    "bg-white rounded-lg shadow-xl",
    what.variant({ size: "md", position: "center" })
  ]),
  header: def.header(["p-4 border-b"]),
  body: def.body(["p-4"]),
  footer: def.footer(["p-4 border-t"]),
  closeButton: def.closeButton(["absolute top-2 right-2"])
}));

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  position?: "center" | "top" | "bottom";
}

function Modal({ 
  isOpen, 
  onClose, 
  children, 
  size = "md", 
  position = "center" 
}: ModalProps) {
  const modalClasses = useCls(ModalCls, ({ what }) => ({
    variant: what.variant({ size, position })
  }));
  
  if (!isOpen) return null;
  
  return (
    <div className={modalClasses.overlay()} onClick={onClose}>
      <div className={modalClasses.container()} onClick={e => e.stopPropagation()}>
        <button className={modalClasses.closeButton()} onClick={onClose}>
          √ó
        </button>
        {children}
      </div>
    </div>
  );
}

// Slot components
function ModalHeader({ children }: { children: React.ReactNode }) {
  const modalClasses = useCls(ModalCls);
  return <div className={modalClasses.header()}>{children}</div>;
}

function ModalBody({ children }: { children: React.ReactNode }) {
  const modalClasses = useCls(ModalCls);
  return <div className={modalClasses.body()}>{children}</div>;
}

function ModalFooter({ children }: { children: React.ReactNode }) {
  const modalClasses = useCls(ModalCls);
  return <div className={modalClasses.footer()}>{children}</div>;
}
```

### **Context-Based Composition**

Use React Context for component composition:

```tsx
const FormCls = cls({
  slot: ["root", "field", "label", "input", "error"],
  variant: {
    layout: ["horizontal", "vertical"],
    size: ["sm", "md", "lg"]
  }
}, ({ what, def }) => ({
  root: def.root([
    "space-y-4",
    what.variant({ layout: "vertical", size: "md" })
  ]),
  field: def.field(["flex flex-col"]),
  label: def.label(["text-sm font-medium"]),
  input: def.input(["border rounded px-3 py-2"]),
  error: def.error(["text-red-500 text-sm"])
}));

interface FormContextValue {
  layout: "horizontal" | "vertical";
  size: "sm" | "md" | "lg";
}

const FormContext = createContext<FormContextValue | null>(null);

function Form({ 
  children, 
  layout = "vertical", 
  size = "md" 
}: { 
  children: React.ReactNode;
  layout?: "horizontal" | "vertical";
  size?: "sm" | "md" | "lg";
}) {
  const formClasses = useCls(FormCls, ({ what }) => ({
    variant: what.variant({ layout, size })
  }));
  
  return (
    <FormContext value={{ layout, size }}>
      <form className={formClasses.root()}>
        {children}
      </form>
    </FormContext>
  );
}

function FormField({ 
  label, 
  error, 
  children 
}: { 
  label: string;
  error?: string;
  children: React.ReactNode;
}) {
  const formClasses = useCls(FormCls);
  const context = useContext(FormContext);
  
  return (
    <div className={formClasses.field()}>
      <label className={formClasses.label()}>{label}</label>
      {children}
      {error && <div className={formClasses.error()}>{error}</div>}
    </div>
  );
}
```

## üéØ Advanced Patterns

### **Polymorphic Component Pattern**

Create components that can render as different HTML elements:

```tsx
interface PolymorphicProps {
  as?: keyof JSX.IntrinsicElements;
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary";
}

function PolymorphicButton({ 
  as: Component = "button", 
  children, 
  size = "md", 
  tone = "primary",
  ...props 
}: PolymorphicProps) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  
  return (
    <Component className={buttonClasses.root()} {...props}>
      {children}
    </Component>
  );
}

// Usage
<PolymorphicButton as="a" href="/link">Link Button</PolymorphicButton>
<PolymorphicButton as="div" onClick={handleClick}>Div Button</PolymorphicButton>
```

### **Controlled Component Pattern**

Create components that work in both controlled and uncontrolled modes:

```tsx
interface ControlledInputProps {
  value?: string;
  defaultValue?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
}

function ControlledInput({ 
  value, 
  defaultValue, 
  onChange, 
  placeholder,
  disabled = false 
}: ControlledInputProps) {
  const [internalValue, setInternalValue] = useState(defaultValue || "");
  const isControlled = value !== undefined;
  const currentValue = isControlled ? value : internalValue;
  
  const inputClasses = useCls(InputCls, ({ what }) => ({
    variant: what.variant({ disabled })
  }));
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    
    if (!isControlled) {
      setInternalValue(newValue);
    }
    
    onChange?.(newValue);
  };
  
  return (
    <input
      className={inputClasses.root()}
      value={currentValue}
      onChange={handleChange}
      placeholder={placeholder}
      disabled={disabled}
    />
  );
}
```

## üîç Best Practices

### **1. Consistent API Design**

```tsx
// ‚úÖ Good: Consistent prop naming
interface ButtonProps {
  size: "sm" | "md" | "lg";
  tone: "primary" | "secondary" | "danger";
  disabled: boolean;
}

// ‚ùå Avoid: Inconsistent prop naming
interface ButtonProps {
  buttonSize: "small" | "medium" | "large";
  buttonTone: "primary" | "secondary" | "danger";
  isDisabled: boolean;
}
```

### **2. Type-Safe Variants**

```tsx
// ‚úÖ Good: Type-safe variant usage
const buttonClasses = useCls(ButtonCls, ({ what }) => ({
  variant: what.variant({ size, tone, disabled })
}));

// ‚ùå Avoid: Manual variant construction
const buttonClasses = useCls(ButtonCls, () => ({
  variant: { size, tone, disabled } // No type safety
}));
```

### **3. Proper Slot Usage**

```tsx
// ‚úÖ Good: Use slots for component parts
function Button({ children, icon }) {
  const buttonClasses = useCls(ButtonCls);
  
  return (
    <button className={buttonClasses.root()}>
      {icon && <span className={buttonClasses.icon()}>{icon}</span>}
      <span className={buttonClasses.label()}>{children}</span>
    </button>
  );
}

// ‚ùå Avoid: Hard-coded class names
function Button({ children, icon }) {
  return (
    <button className="px-4 py-2 bg-blue-600 text-white rounded">
      {icon && <span className="w-4 h-4 mr-2">{icon}</span>}
      <span>{children}</span>
    </button>
  );
}
```

## üöÄ What's Next?

Now that you understand Component Patterns, you're ready to explore:

- **[4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)**: Deep dive into provider architecture
- **[4.6 Component Creation](./4.6-component-creation.md)**: Building production-ready components
- **[4.7 Theming & Tokens](./4.7-theming-tokens.md)**: Advanced theming patterns

Component Patterns are the building blocks of scalable, maintainable React applications with CLS. Use them to create robust component libraries! üéâ

---

**Previous:** [4.3 Context Integration](./4.3-context-integration.md) | **Next:** [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)
