# 4.6 Component Creation

This chapter provides a **step-by-step guide** for creating production-ready React components with CLS. You'll learn how to design, implement, and maintain components that are type-safe, reusable, and follow CLS best practices.

## 🎯 Component Creation Process

Creating a CLS-powered React component involves several key steps:

1. **Define the Contract** - Specify slots, variants, and tokens
2. **Create the Definition** - Implement styling rules and defaults
3. **Design the Interface** - Define TypeScript props and component API
4. **Implement the Component** - Build the React component with CLS integration
5. **Add Documentation** - Document usage, examples, and API

## 📝 Step 1: Define the Contract

Start by defining what your component needs:

```tsx
import { cls } from "@use-pico/cls";

// Define the component's styling contract
const ButtonCls = cls({
  // Slots: Named parts of the component
  slot: ["root", "label", "icon", "loading"],
  
  // Variants: Configurable properties that affect appearance
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger", "ghost"],
    disabled: [true, false],
    loading: [true, false]
  },
  
  // Tokens: Design values that can be overridden
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      danger: ["bg-red-600"],
      ghost: ["bg-transparent"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-white"],
      danger: ["text-white"],
      ghost: ["text-gray-700"]
    },
    "spacing": {
      sm: ["px-3 py-1.5"],
      md: ["px-4 py-2"],
      lg: ["px-6 py-3"]
    }
  }
});
```

## 🎨 Step 2: Create the Definition

Implement the styling logic and rules:

```tsx
const ButtonCls = cls({
  slot: ["root", "label", "icon", "loading"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger", "ghost"],
    disabled: [true, false],
    loading: [true, false]
  },
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      danger: ["bg-red-600"],
      ghost: ["bg-transparent"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-white"],
      danger: ["text-white"],
      ghost: ["text-gray-700"]
    },
    "spacing": {
      sm: ["px-3 py-1.5"],
      md: ["px-4 py-2"],
      lg: ["px-6 py-3"]
    }
  }
}, ({ what, def }) => ({
  // Root slot: Main button element
  root: def.root([
    "inline-flex items-center justify-center rounded font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2",
    what.variant({ size: "md", tone: "primary", disabled: false, loading: false })
  ]),
  
  // Label slot: Button text
  label: def.label([
    "text-sm font-medium"
  ]),
  
  // Icon slot: Optional icon
  icon: def.icon([
    "w-4 h-4"
  ]),
  
  // Loading slot: Loading spinner
  loading: def.loading([
    "w-4 h-4 animate-spin"
  ])
}));
```

## 🔧 Step 3: Design the Interface

Define the component's TypeScript interface:

```tsx
// Component props interface
interface ButtonProps {
  // Content
  children: React.ReactNode;
  
  // Variants
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary" | "danger" | "ghost";
  disabled?: boolean;
  loading?: boolean;
  
  // Content options
  icon?: React.ReactNode;
  iconPosition?: "left" | "right";
  
  // HTML button props
  type?: "button" | "submit" | "reset";
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  
  // Accessibility
  "aria-label"?: string;
  
  // Additional props
  className?: string;
  style?: React.CSSProperties;
}
```

## ⚡ Step 4: Implement the Component

Build the React component with CLS integration:

```tsx
import { cls } from "@use-pico/cls";
import { useCls } from "@use-pico/cls/react";

// ... ButtonCls definition from previous steps ...

function Button({ 
  children, 
  size = "md", 
  tone = "primary", 
  disabled = false,
  loading = false,
  icon,
  iconPosition = "left",
  type = "button",
  onClick,
  "aria-label": ariaLabel,
  className,
  style,
  ...props 
}: ButtonProps) {
  // Get CLS classes
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone, disabled, loading })
  }));
  
  // Determine if button should be disabled
  const isDisabled = disabled || loading;
  
  // Handle click events
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    if (isDisabled) {
      event.preventDefault();
      return;
    }
    onClick?.(event);
  };
  
  // Render icon based on position
  const renderIcon = () => {
    if (!icon && !loading) return null;
    
    const iconContent = loading ? (
      <svg className={buttonClasses.loading()} fill="none" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
        <path fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
      </svg>
    ) : (
      <span className={buttonClasses.icon()}>{icon}</span>
    );
    
    return iconContent;
  };
  
  return (
    <button
      type={type}
      disabled={isDisabled}
      onClick={handleClick}
      aria-label={ariaLabel}
      aria-disabled={isDisabled}
      className={buttonClasses.root()}
      style={style}
      {...props}
    >
      {iconPosition === "left" && renderIcon()}
      <span className={buttonClasses.label()}>{children}</span>
      {iconPosition === "right" && renderIcon()}
    </button>
  );
}

export { Button, ButtonCls };
```

## 📚 Step 5: Add Documentation

Document your component with examples and API reference:

```tsx
/**
 * Button Component
 * 
 * A versatile button component with multiple variants, sizes, and states.
 * 
 * @example
 * ```tsx
 * // Basic usage
 * <Button>Click me</Button>
 * 
 * // With variants
 * <Button size="lg" tone="danger" disabled>
 *   Delete Item
 * </Button>
 * 
 * // With icon
 * <Button icon={<Icon name="plus" />} iconPosition="left">
 *   Add Item
 * </Button>
 * 
 * // Loading state
 * <Button loading>Processing...</Button>
 * ```
 */
function Button({ ... }: ButtonProps) {
  // ... implementation
}
```

## 🎯 Advanced Component Features

### **Compound Components**

Create components that work together:

```tsx
// Main component
function ButtonGroup({ 
  children, 
  orientation = "horizontal" 
}: { 
  children: React.ReactNode;
  orientation?: "horizontal" | "vertical";
}) {
  const groupClasses = useCls(ButtonGroupCls, ({ what }) => ({
    variant: what.variant({ orientation })
  }));
  
  return <div className={groupClasses.root()}>{children}</div>;
}

// Sub-components
function ButtonGroupItem({ children }: { children: React.ReactNode }) {
  const groupClasses = useCls(ButtonGroupCls);
  return <div className={groupClasses.item()}>{children}</div>;
}

// Usage
<ButtonGroup orientation="vertical">
  <ButtonGroupItem>
    <Button tone="primary">Primary</Button>
  </ButtonGroupItem>
  <ButtonGroupItem>
    <Button tone="secondary">Secondary</Button>
  </ButtonGroupItem>
</ButtonGroup>
```

### **Render Props Pattern**

Create flexible components:

```tsx
interface ButtonRenderProps {
  isDisabled: boolean;
  isLoading: boolean;
  classes: ReturnType<typeof useCls>;
}

interface ButtonWithRenderProps extends Omit<ButtonProps, 'children'> {
  children: (props: ButtonRenderProps) => React.ReactNode;
}

function ButtonWithRender({ 
  children, 
  size = "md", 
  tone = "primary", 
  disabled = false,
  loading = false,
  ...props 
}: ButtonWithRenderProps) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone, disabled, loading })
  }));
  
  const isDisabled = disabled || loading;
  
  return (
    <button
      disabled={isDisabled}
      className={buttonClasses.root()}
      {...props}
    >
      {children({ isDisabled, isLoading: loading, classes: buttonClasses })}
    </button>
  );
}

// Usage
<ButtonWithRender size="lg" tone="danger">
  {({ isDisabled, isLoading, classes }) => (
    <>
      {isLoading && <span className={classes.loading()}>Loading...</span>}
      <span className={classes.label()}>
        {isDisabled ? "Processing..." : "Delete Item"}
      </span>
    </>
  )}
</ButtonWithRender>
```

### **Polymorphic Components**

Components that can render as different HTML elements:

```tsx
interface PolymorphicButtonProps extends Omit<ButtonProps, 'as'> {
  as?: keyof JSX.IntrinsicElements;
}

function PolymorphicButton({ 
  as: Component = "button", 
  children, 
  size = "md", 
  tone = "primary",
  ...props 
}: PolymorphicButtonProps) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  
  return (
    <Component className={buttonClasses.root()} {...props}>
      <span className={buttonClasses.label()}>{children}</span>
    </Component>
  );
}

// Usage
<PolymorphicButton as="a" href="/link">Link Button</PolymorphicButton>
<PolymorphicButton as="div" onClick={handleClick}>Div Button</PolymorphicButton>
```

## 🔍 Best Practices

### **1. Consistent API Design**

```tsx
// ✅ Good: Consistent prop naming
interface ButtonProps {
  size: "sm" | "md" | "lg";
  tone: "primary" | "secondary" | "danger";
  disabled: boolean;
}

// ❌ Avoid: Inconsistent prop naming
interface ButtonProps {
  buttonSize: "small" | "medium" | "large";
  buttonTone: "primary" | "secondary" | "danger";
  isDisabled: boolean;
}
```

### **2. Proper Type Safety**

```tsx
// ✅ Good: Type-safe variant usage
const buttonClasses = useCls(ButtonCls, ({ what }) => ({
  variant: what.variant({ size, tone, disabled })
}));

// ❌ Avoid: Manual variant construction
const buttonClasses = useCls(ButtonCls, () => ({
  variant: { size, tone, disabled } // No type safety
}));
```

### **3. Accessibility First**

```tsx
// ✅ Good: Proper accessibility attributes
<button
  disabled={isDisabled}
  aria-label={ariaLabel}
  aria-disabled={isDisabled}
  onClick={handleClick}
>
  {children}
</button>

// ❌ Avoid: Missing accessibility
<button onClick={handleClick}>
  {children}
</button>
```

### **4. Performance Considerations**

```tsx
// ✅ Good: Stable CLS instances
const ButtonCls = cls({ /* ... */ });

// ❌ Avoid: Creating CLS instances in components
function Button() {
  const ButtonCls = cls({ /* ... */ }); // New instance every render!
  // ...
}
```

## 🚀 Component Testing

Test your components thoroughly:

```tsx
// Component test example
describe("Button", () => {
  it("renders with default props", () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole("button")).toHaveTextContent("Click me");
  });
  
  it("applies correct classes for variants", () => {
    render(<Button size="lg" tone="danger">Delete</Button>);
    const button = screen.getByRole("button");
    expect(button).toHaveClass("px-6", "py-3", "bg-red-600");
  });
  
  it("handles disabled state", () => {
    render(<Button disabled>Disabled</Button>);
    expect(screen.getByRole("button")).toBeDisabled();
  });
  
  it("handles loading state", () => {
    render(<Button loading>Loading</Button>);
    expect(screen.getByRole("button")).toBeDisabled();
    expect(screen.getByRole("button")).toHaveClass("animate-spin");
  });
});
```

## 🎯 Component Export Pattern

Export your components with proper TypeScript support:

```tsx
// components/Button/index.ts
export { Button } from "./Button";
export type { ButtonProps } from "./Button";
export { ButtonCls } from "./ButtonCls";

// components/Button/Button.tsx
export interface ButtonProps {
  // ... props interface
}

export function Button({ ... }: ButtonProps) {
  // ... implementation
}

// components/Button/ButtonCls.ts
export const ButtonCls = cls({
  // ... CLS definition
});

// Usage
import { Button, type ButtonProps } from "./components/Button";
```

## 🚀 What's Next?

Now that you understand Component Creation, you're ready to explore:

- **[4.7 Theming & Tokens](./4.7-theming-tokens.md)**: Advanced theming patterns
- **[Chapter 5: Tokens](../05-tokens/README.md)**: Deep dive into token system
- **[Chapter 6: Slots](../06-slots/README.md)**: Mastering component slots

Component Creation is the foundation for building robust, maintainable React applications with CLS. Use these patterns to create production-ready components! 🎉

## Table of Contents
- [4.1 `useCls` Hook](./4.1-usecls-hook.md)
- [4.2 `withCls` HOC](./4.2-withcls-hoc.md)
- [4.3 Context Integration](./4.3-context-integration.md)
- [4.4 `Component` Patterns](./4.4-component-patterns.md)
- [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)
- [4.6 Component Creation](./4.6-component-creation.md) *(current)*
- [4.7 Theming & Tokens](./4.7-theming-tokens.md)

---

**Previous:** [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md) | **Next:** [4.7 Theming & Tokens](./4.7-theming-tokens.md)
