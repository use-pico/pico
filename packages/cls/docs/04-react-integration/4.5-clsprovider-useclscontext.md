# 4.5 `ClsProvider` & `useClsContext`

The `ClsProvider` and `useClsContext` are the **core infrastructure** for CLS's React Context integration. They enable global styling contexts, theme inheritance, and type-safe token sharing throughout your component tree.

## üéØ What are `ClsProvider` & `useClsContext`?

These utilities provide the foundation for CLS's context system:

- **`ClsProvider`**: A React Context Provider that makes CLS instances available to child components
- **`useClsContext`**: A hook that retrieves the current CLS context instance
- **`useClsFromContext`**: An alias for `useClsContext` for better semantic clarity

Think of them as the **styling context infrastructure** that powers theme inheritance and global styling.

## üìù Basic Provider Setup

```tsx
import { cls } from "@use-pico/cls";
import { ClsProvider, useClsContext } from "@use-pico/cls/react";

// Define a theme CLS instance
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      danger: ["bg-red-600"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-gray-900"]
    },
    "spacing": {
      sm: ["p-2"],
      md: ["p-4"],
      lg: ["p-6"]
    }
  }
});

// Provider component
function App() {
  return (
    <ClsProvider value={ThemeCls}>
      <div className="min-h-screen bg-gray-50">
        <Header />
        <MainContent />
        <Footer />
      </div>
    </ClsProvider>
  );
}

// Consumer component
function Button({ children }: { children: React.ReactNode }) {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // Use context tokens directly
    const buttonClasses = contextCls.create();
    return <button className={buttonClasses.root()}>{children}</button>;
  }
  
  // Fallback when no context is available
  return <button className="px-4 py-2 bg-blue-600 text-white rounded">{children}</button>;
}
```

## üîß Provider Architecture

### **Provider Signature**

```typescript
function ClsProvider({
  children,
  value
}: {
  children: ReactNode;
  value: Cls<any>;
}): JSX.Element
```

### **Context Hook Signatures**

```typescript
function useClsContext(): Cls<any> | undefined
function useClsFromContext(): Cls<any> | undefined
```

### **Context Value Structure**

The context provides a complete CLS instance with:
- **Contract**: Type information and structure
- **Definition**: Styling rules and token definitions
- **Methods**: `create()`, `extend()`, `use()`, etc.

## üé® Advanced Provider Patterns

### **Nested Provider Architecture**

Create a hierarchy of styling contexts:

```tsx
// Global application theme
const GlobalThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-gray-900"]
    }
  }
});

// Component-specific theme
const ButtonThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-green-600"], // Overrides global
      danger: ["bg-red-600"]     // New token
    }
  }
});

// Layout-specific theme
const LayoutThemeCls = cls({
  token: {
    "spacing": {
      container: ["p-6"],
      section: ["p-4"]
    }
  }
});

function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      
      <ClsProvider value={LayoutThemeCls}>
        <MainContent />
      </ClsProvider>
      
      <ClsProvider value={ButtonThemeCls}>
        <ButtonSection />
      </ClsProvider>
      
      <Footer />
    </ClsProvider>
  );
}
```

### **Dynamic Provider Values**

Update context values based on application state:

```tsx
function ThemeProvider({ 
  children, 
  theme 
}: { 
  children: React.ReactNode;
  theme: "light" | "dark" | "custom";
}) {
  const [themeCls, setThemeCls] = useState<Cls<any>>(LightThemeCls);
  
  useEffect(() => {
    switch (theme) {
      case "light":
        setThemeCls(LightThemeCls);
        break;
      case "dark":
        setThemeCls(DarkThemeCls);
        break;
      case "custom":
        setThemeCls(CustomThemeCls);
        break;
    }
  }, [theme]);
  
  return (
    <ClsProvider value={themeCls}>
      {children}
    </ClsProvider>
  );
}

// Usage
function App() {
  const [currentTheme, setCurrentTheme] = useState<"light" | "dark" | "custom">("light");
  
  return (
    <ThemeProvider theme={currentTheme}>
      <div>
        <button onClick={() => setCurrentTheme("dark")}>Dark Theme</button>
        <button onClick={() => setCurrentTheme("light")}>Light Theme</button>
        <ThemedContent />
      </div>
    </ThemeProvider>
  );
}
```

### **Provider Composition**

Combine multiple providers for complex styling scenarios:

```tsx
function StylingProvider({ 
  children, 
  theme, 
  layout, 
  components 
}: {
  children: React.ReactNode;
  theme: Cls<any>;
  layout: Cls<any>;
  components: Cls<any>;
}) {
  return (
    <ClsProvider value={theme}>
      <ClsProvider value={layout}>
        <ClsProvider value={components}>
          {children}
        </ClsProvider>
      </ClsProvider>
    </ClsProvider>
  );
}

// Usage
function App() {
  return (
    <StylingProvider 
      theme={ThemeCls}
      layout={LayoutCls}
      components={ComponentCls}
    >
      <Application />
    </StylingProvider>
  );
}
```

## üîç Context Access Patterns

### **Direct Context Usage**

Access and use the context CLS instance directly:

```tsx
function ThemeAwareComponent() {
  const contextCls = useClsContext();
  
  if (!contextCls) {
    return <div>No theme context available</div>;
  }
  
  // Use context CLS directly
  const themeClasses = contextCls.create();
  
  return (
    <div className={themeClasses.root()}>
      <h1 className={themeClasses.title()}>Themed Content</h1>
      <p className={themeClasses.text()}>This content uses theme tokens</p>
    </div>
  );
}
```

### **Context with Component CLS**

Combine context tokens with component-specific styling:

```tsx
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"]
  }
}, ({ what, def }) => ({
  root: def.root([
    "rounded font-medium transition-colors",
    what.variant({ size: "md" })
  ])
}));

function ThemedButton({ 
  children, 
  size = "md" 
}: { 
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
}) {
  const contextCls = useClsContext();
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ size })
  }));
  
  // Context tokens are automatically merged with component tokens
  return <button className={buttonClasses.root()}>{children}</button>;
}
```

### **Context-Aware Components**

Create components that adapt to available context:

```tsx
function AdaptiveComponent() {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // Use context if available
    const classes = contextCls.create();
    return (
      <div className={classes.container()}>
        <h2 className={classes.title()}>Context-Aware Title</h2>
        <p className={classes.text()}>This component uses context tokens</p>
      </div>
    );
  }
  
  // Fallback styling when no context is available
  return (
    <div className="p-4 bg-white border rounded">
      <h2 className="text-xl font-bold text-gray-900">Default Title</h2>
      <p className="text-gray-600">This component uses fallback styling</p>
    </div>
  );
}
```

## ‚ö° Performance Considerations

### **Provider Value Stability**

Ensure provider values are stable to prevent unnecessary re-renders:

```tsx
// ‚úÖ Good: Stable CLS instances
const LightThemeCls = cls({ token: { /* light theme */ } });
const DarkThemeCls = cls({ token: { /* dark theme */ } });

function App({ theme }: { theme: "light" | "dark" }) {
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <Application />
    </ClsProvider>
  );
}

// ‚ùå Avoid: Creating new CLS instances on every render
function App({ theme }: { theme: "light" | "dark" }) {
  const themeCls = cls({ 
    token: theme === "dark" ? darkTokens : lightTokens 
  }); // New instance every render!
  
  return (
    <ClsProvider value={themeCls}>
      <Application />
    </ClsProvider>
  );
}
```

### **Context Depth Optimization**

Minimize context nesting depth for better performance:

```tsx
// ‚ùå Avoid: Deep context nesting
function DeepNesting() {
  return (
    <ClsProvider value={Theme1Cls}>
      <ClsProvider value={Theme2Cls}>
        <ClsProvider value={Theme3Cls}>
          <ClsProvider value={Theme4Cls}>
            <Component /> {/* 4 levels deep */}
          </ClsProvider>
        </ClsProvider>
      </ClsProvider>
    </ClsProvider>
  );
}

// ‚úÖ Good: Flattened context structure
function FlattenedContext() {
  // Merge multiple themes into a single CLS instance
  const mergedThemeCls = Theme1Cls.use(Theme2Cls).use(Theme3Cls).use(Theme4Cls);
  
  return (
    <ClsProvider value={mergedThemeCls}>
      <Component /> {/* Single level */}
    </ClsProvider>
  );
}
```

## üéØ Best Practices

### **1. Meaningful Context Boundaries**

```tsx
// ‚úÖ Good: Logical context boundaries
function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      <MainContent />
      <Footer />
    </ClsProvider>
  );
}

// ‚ùå Avoid: Unnecessary context nesting
function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <ClsProvider value={GlobalThemeCls}> {/* Redundant */}
        <Component />
      </ClsProvider>
    </ClsProvider>
  );
}
```

### **2. Type-Safe Context Usage**

```tsx
// ‚úÖ Good: Type-safe context access
function ThemeAwareComponent() {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // TypeScript knows about context tokens
    const classes = contextCls.create();
    return <div className={classes.root()}>Themed</div>;
  }
  
  return <div>No theme</div>;
}

// ‚ùå Avoid: Unsafe context usage
function ThemeAwareComponent() {
  const contextCls = useClsContext();
  
  // No type checking on context usage
  return <div className={contextCls?.create()?.root() || ""}>Themed</div>;
}
```

### **3. Context Fallbacks**

```tsx
// ‚úÖ Good: Graceful context fallbacks
function AdaptiveComponent() {
  const contextCls = useClsContext();
  
  if (contextCls) {
    const classes = contextCls.create();
    return <div className={classes.container()}>Context-aware</div>;
  }
  
  // Fallback when no context is available
  return <div className="p-4 bg-white border rounded">Default styling</div>;
}
```

## üîç Common Patterns

### **Theme Switching**

```tsx
function ThemeSwitcher() {
  const [theme, setTheme] = useState<"light" | "dark">("light");
  
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <div>
        <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
          Switch to {theme === "light" ? "Dark" : "Light"} Theme
        </button>
        <ThemedContent />
      </div>
    </ClsProvider>
  );
}
```

### **Component-Specific Theming**

```tsx
function CardSection({ children }: { children: React.ReactNode }) {
  return (
    <ClsProvider value={CardThemeCls}>
      <div className="grid gap-4">
        {children}
      </div>
    </ClsProvider>
  );
}

function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      <CardSection>
        <Card>Content 1</Card>
        <Card>Content 2</Card>
      </CardSection>
    </ClsProvider>
  );
}
```

### **Runtime Theme Overrides**

```tsx
function DynamicThemeProvider({ 
  children, 
  overrides 
}: { 
  children: React.ReactNode;
  overrides?: Record<string, string[]>;
}) {
  const baseThemeCls = useClsContext();
  
  if (!baseThemeCls || !overrides) {
    return <>{children}</>;
  }
  
  // Create a new CLS instance with runtime overrides
  const dynamicThemeCls = baseThemeCls.extend({
    token: overrides
  });
  
  return (
    <ClsProvider value={dynamicThemeCls}>
      {children}
    </ClsProvider>
  );
}
```

## üöÄ What's Next?

Now that you understand `ClsProvider` & `useClsContext`, you're ready to explore:

- **[4.6 Component Creation](./4.6-component-creation.md)**: Building production-ready components
- **[4.7 Theming & Tokens](./4.7-theming-tokens.md)**: Advanced theming patterns
- **[Chapter 5: Tokens](../05-tokens/README.md)**: Deep dive into token system

`ClsProvider` & `useClsContext` are the foundation for building scalable, themeable applications with CLS. Use them to create consistent, maintainable styling systems! üéâ

## Table of Contents
- [4.1 `useCls` Hook](./4.1-usecls-hook.md)
- [4.2 `withCls` HOC](./4.2-withcls-hoc.md)
- [4.3 Context Integration](./4.3-context-integration.md)
- [4.4 `Component` Patterns](./4.4-component-patterns.md)
- [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md) *(current)*
- [4.6 Component Creation](./4.6-component-creation.md)
- [4.7 Theming & Tokens](./4.7-theming-tokens.md)

---

**Previous:** [4.4 `Component` Patterns](./4.4-component-patterns.md) | **Next:** [4.6 Component Creation](./4.6-component-creation.md)
