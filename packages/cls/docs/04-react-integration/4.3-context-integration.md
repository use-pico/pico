# 4.3 Context Integration

## Table of Contents
- [4.1 `useCls` Hook](./4.1-usecls-hook.md)
- [4.2 `withCls` HOC](./4.2-withcls-hoc.md)
- [4.3 Context Integration](./4.3-context-integration.md) *(current)*
- [4.4 `Component` Patterns](./4.4-component-patterns.md)
- [4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)
- [4.6 Component Creation](./4.6-component-creation.md)
- [4.7 Theming & Tokens](./4.7-theming-tokens.md)

---

CLS seamlessly integrates with React's Context API, enabling **theme inheritance** and **global styling contexts** throughout your component tree. This integration allows you to provide styling tokens and configurations at any level and have them automatically inherited by child components.

## üéØ What is Context Integration?

Context Integration in CLS allows you to:
- **Provide global themes** through React Context
- **Inherit styling tokens** automatically in child components
- **Override tokens** at any level in the component tree
- **Maintain type safety** across the entire context chain

Think of it as **styling inheritance** - parent components can provide styling context that child components automatically receive and can override.

## üìù Basic Context Setup

```tsx
import { cls } from "@use-pico/cls";
import { ClsProvider, useCls } from "@use-pico/cls/react";

// Define a theme CLS instance
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"],
      danger: ["bg-red-600"]
    },
    "color.text": {
      primary: ["text-white"],
      secondary: ["text-gray-900"]
    }
  }
});

// Define a component CLS instance
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    tone: ["primary", "secondary", "danger"]
  }
}, ({ what, def }) => ({
  root: def.root([
    "px-4 py-2 rounded font-medium",
    what.variant({ tone: "primary" })
  ])
}));

// Provider component
function App() {
  return (
    <ClsProvider value={ThemeCls}>
      <Button>I inherit theme tokens!</Button>
    </ClsProvider>
  );
}

// Consumer component
function Button({ children }: { children: React.ReactNode }) {
  const buttonClasses = useCls(ButtonCls, ({ what }) => ({
    variant: what.variant({ tone: "primary" })
  }));
  
  // Automatically gets theme tokens from context!
  return <button className={buttonClasses.root()}>{children}</button>;
}
```

## üîß Context Token Merging

CLS automatically merges context tokens with component tokens, with **component tokens taking precedence**:

```tsx
// Context provides base tokens
const ThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    }
  }
});

// Component overrides specific tokens
const ButtonCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-green-600"], // Overrides context primary
      danger: ["bg-red-600"]     // New token not in context
    }
  }
});

function Button({ children }: { children: React.ReactNode }) {
  const buttonClasses = useCls(ButtonCls);
  
  // Result: 
  // - primary = green (from component, overrides context)
  // - secondary = gray (from context)
  // - danger = red (from component)
  
  return <button className={buttonClasses.root()}>{children}</button>;
}
```

## üé® Advanced Context Patterns

### **Nested Context Providers**

You can nest multiple context providers for different styling concerns:

```tsx
// Global theme context
const GlobalThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-600"]
    }
  }
});

// Component-specific context
const ButtonThemeCls = cls({
  token: {
    "color.bg": {
      primary: ["bg-green-600"], // Overrides global
      danger: ["bg-red-600"]     // New token
    }
  }
});

function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <div>
        <Button>Uses global theme</Button>
        
        <ClsProvider value={ButtonThemeCls}>
          <Button>Uses button theme</Button>
        </ClsProvider>
      </div>
    </ClsProvider>
  );
}
```

### **Conditional Context**

Provide different contexts based on conditions:

```tsx
function App({ theme }: { theme: "light" | "dark" }) {
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <Button>Adapts to theme</Button>
    </ClsProvider>
  );
}
```

### **Context with Runtime Overrides**

Combine context inheritance with runtime token overrides:

```tsx
function ThemedButton({ 
  children, 
  customColor 
}: { 
  children: React.ReactNode;
  customColor?: string;
}) {
  const buttonClasses = useCls(ButtonCls, 
    // User config
    ({ what }) => ({
      variant: what.variant({ tone: "primary" })
    }),
    // Runtime overrides (highest precedence)
    ({ override }) => ({
      token: override.token({
        "color.bg": {
          primary: customColor ? [customColor] : undefined
        }
      })
    })
  );
  
  return <button className={buttonClasses.root()}>{children}</button>;
}
```

## üîç Context Access Patterns

### **Direct Context Access**

Access the context CLS instance directly:

```tsx
import { useClsContext } from "@use-pico/cls/react";

function ThemeAwareComponent() {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // Use context CLS directly
    const themeClasses = contextCls.create();
    return <div className={themeClasses.root()}>Theme aware</div>;
  }
  
  return <div>No theme context</div>;
}
```

### **Context-Aware Components**

Create components that work with or without context:

```tsx
function FlexibleButton({ children }: { children: React.ReactNode }) {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // Use context if available
    const buttonClasses = useCls(ButtonCls);
    return <button className={buttonClasses.root()}>{children}</button>;
  } else {
    // Fallback to default styling
    return <button className="px-4 py-2 bg-blue-600 text-white rounded">{children}</button>;
  }
}
```

## ‚ö° Performance Considerations

### **Context Updates**

Context changes trigger re-renders in all consuming components:

```tsx
// ‚ùå Avoid: Creating new CLS instances on every render
function App({ theme }) {
  const themeCls = cls({ token: { /* theme-specific tokens */ } }); // New instance every render!
  
  return (
    <ClsProvider value={themeCls}>
      <Button />
    </ClsProvider>
  );
}

// ‚úÖ Good: Use stable CLS instances
const LightThemeCls = cls({ token: { /* light theme */ } });
const DarkThemeCls = cls({ token: { /* dark theme */ } });

function App({ theme }) {
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <Button />
    </ClsProvider>
  );
}
```

### **Context Depth**

Deep context nesting can impact performance:

```tsx
// ‚ùå Avoid: Too many nested providers
function DeepNesting() {
  return (
    <ClsProvider value={Theme1Cls}>
      <ClsProvider value={Theme2Cls}>
        <ClsProvider value={Theme3Cls}>
          <ClsProvider value={Theme4Cls}>
            <Button /> {/* 4 levels deep */}
          </ClsProvider>
        </ClsProvider>
      </ClsProvider>
    </ClsProvider>
  );
}

// ‚úÖ Good: Flatten context structure
function FlattenedContext() {
  return (
    <ClsProvider value={MergedThemeCls}>
      <Button /> {/* Single level */}
    </ClsProvider>
  );
}
```

## üéØ Best Practices

### **1. Stable Context Values**

```tsx
// ‚úÖ Good: Stable CLS instances
const LightThemeCls = cls({ token: { /* ... */ } });
const DarkThemeCls = cls({ token: { /* ... */ } });

// ‚ùå Avoid: Dynamic CLS creation
function App({ theme }) {
  const themeCls = cls({ token: theme === "dark" ? darkTokens : lightTokens });
  return <ClsProvider value={themeCls}>...</ClsProvider>;
}
```

### **2. Meaningful Context Boundaries**

```tsx
// ‚úÖ Good: Logical context boundaries
function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      <MainContent />
      <Footer />
    </ClsProvider>
  );
}

// ‚ùå Avoid: Unnecessary context nesting
function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <ClsProvider value={GlobalThemeCls}> {/* Redundant */}
        <Button />
      </ClsProvider>
    </ClsProvider>
  );
}
```

### **3. Type-Safe Context Usage**

```tsx
// ‚úÖ Good: Type-safe context access
function ThemeAwareComponent() {
  const contextCls = useClsContext();
  
  if (contextCls) {
    // TypeScript knows about context tokens
    const classes = contextCls.create();
    return <div className={classes.root()}>Themed</div>;
  }
  
  return <div>No theme</div>;
}
```

## üîç Common Patterns

### **Theme Switching**

```tsx
function ThemeSwitcher() {
  const [theme, setTheme] = useState<"light" | "dark">("light");
  
  const themeCls = theme === "dark" ? DarkThemeCls : LightThemeCls;
  
  return (
    <ClsProvider value={themeCls}>
      <div>
        <Button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
          Switch Theme
        </Button>
        <ThemedContent />
      </div>
    </ClsProvider>
  );
}
```

### **Component-Specific Theming**

```tsx
function CardSection({ children }: { children: React.ReactNode }) {
  return (
    <ClsProvider value={CardThemeCls}>
      <div className="grid gap-4">
        {children}
      </div>
    </ClsProvider>
  );
}

function App() {
  return (
    <ClsProvider value={GlobalThemeCls}>
      <Header />
      <CardSection>
        <Card>Content 1</Card>
        <Card>Content 2</Card>
      </CardSection>
    </ClsProvider>
  );
}
```

## üöÄ What's Next?

Now that you understand Context Integration, you're ready to explore:

- **[4.4 `Component` Patterns](./4.4-component-patterns.md)**: Advanced component patterns
- **[4.5 `ClsProvider` & `useClsContext`](./4.5-clsprovider-useclscontext.md)**: Deep dive into provider architecture
- **[4.6 Component Creation](./4.6-component-creation.md)**: Building production-ready components

Context Integration is the foundation for building scalable, themeable applications with CLS. Use it to create consistent, maintainable styling systems! üéâ

---

**Previous:** [4.2 `withCls` HOC](./4.2-withcls-hoc.md) | **Next:** [4.4 `Component` Patterns](./4.4-component-patterns.md)
