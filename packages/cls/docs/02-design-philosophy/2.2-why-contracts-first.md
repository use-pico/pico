# 2.2 Why Contracts First

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md) *(current)*
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

In CLS, **everything starts with a contract**. But why? What's so special about defining your structure upfront? Let's dive into the philosophy behind "contracts first" and why it's a game-changer! 🎯

## What is a Contract? 📋

A contract in CLS is like a **blueprint** for your styling system. It defines:

```typescript
const ButtonContract = {
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label", "icon"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
};
```

Think of it as the **"menu"** - you can only order what's on the menu, but once it's there, you know exactly what you're getting! 🍽️

## The Contract-First Philosophy 🧠

### 1. **Define Once, Use Everywhere** 🎯

When you define a contract, you're creating a **single source of truth** for your styling structure:

```typescript
// Define the contract once
const ButtonCls = cls(ButtonContract, ({ what, def }) => ({
  // Implementation follows the contract structure
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  }),
  rules: [
    def.root({
      root: what.both(["inline-flex", "items-center"], ["color.bg.default"]),
      label: what.css(["font-medium"]),
      icon: what.css(["mr-2"])
    })
  ],
  defaults: def.defaults({
    size: "md",
    tone: "default"
  })
}));
```

**The magic?** TypeScript now knows **exactly** what tokens, slots, and variants are available everywhere you use this button! ✨

### 2. **Type Safety from Day One** 🛡️

Contracts enable **compile-time validation** of your entire styling system:

```typescript
// ✅ This works - "primary" is in the contract
ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));

// ❌ This fails at compile time - "purple" is not in the contract
ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "purple" }) // TypeScript error!
}));
```

No more runtime surprises! TypeScript catches invalid variants, tokens, and slots before your code even runs! 🎉

### 3. **IntelliSense Everywhere** 💡

Once you have a contract, you get **perfect autocomplete** throughout your codebase:

```typescript
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows exactly what's available:
    // size: "sm" | "md" | "lg"
    // tone: "default" | "primary" | "danger"
  })
}));
```

No more guessing what variants exist or remembering token names! 🧠

## The Alternative: Definition-First Approach 😱

Most styling libraries take a "definition-first" approach:

```typescript
// ❌ The "traditional" way (don't do this!)
const ButtonCls = cls({
  // No contract - just start defining things
  variants: {
    size: {
      sm: "px-2 py-1 text-sm",
      md: "px-4 py-2 text-base", 
      lg: "px-6 py-3 text-lg"
    },
    tone: {
      default: "bg-gray-100 text-gray-900",
      primary: "bg-blue-600 text-white",
      danger: "bg-red-500 text-white"
    }
  }
});

// ❌ No type safety, no IntelliSense
const classes = ButtonCls.create({
  size: "xl", // Runtime error! "xl" doesn't exist
  tone: "purple" // Runtime error! "purple" doesn't exist
});
```

**Problems with this approach:**
- **No compile-time validation** - errors only surface at runtime
- **No IntelliSense** - you have to remember what variants exist
- **Inconsistent structure** - every component can have different variants
- **Hard to maintain** - no clear contract for what's available

## Real-World Benefits 🌟

### Consistent Design Systems
```typescript
// All buttons follow the same contract
const PrimaryButton = ButtonCls.extend(primaryContract, definition);
const DangerButton = ButtonCls.extend(dangerContract, definition);
const IconButton = ButtonCls.extend(iconContract, definition);

// TypeScript ensures they all have consistent structure
```

### Refactoring Safety
```typescript
import { contract } from "@use-pico/cls";

// Want to change a variant name? TypeScript catches all usages
const ButtonContract = contract({
  variant: {
    size: ["sm", "md", "lg"],
    // tone: ["default", "primary", "danger"] // Old name
    variant: ["default", "primary", "danger"] // New name
  }
});

// const ButtonCls = cls(ButtonContract, definition); // ButtonCls creation

// TypeScript immediately shows you all the places that need updating:
ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" }) // ❌ Error: 'tone' doesn't exist
}));

// You can't miss any usages - TypeScript won't let you!
```

### Team Collaboration
```typescript
import { cls } from "@use-pico/cls";

// New team member can see exactly what's available
const ButtonCls = cls(ButtonContract, definition);

// They get perfect IntelliSense and can't make mistakes
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript guides them to valid options
  })
}));
```

## The Contract as Documentation 📚

Contracts serve as **living documentation** for your styling system:

```typescript
import { contract } from "@use-pico/cls";

// This contract documents exactly what the button supports
const ButtonContract = contract({
  tokens: {
    "color.bg": ["default", "primary", "danger"], // Available background colors
    "color.text": ["default", "primary", "danger"] // Available text colors
  },
  slot: ["root", "label", "icon"], // Available slots
  variant: {
    size: ["sm", "md", "lg"], // Available sizes
    tone: ["default", "primary", "danger"] // Available tones
  }
});
```

**No more guessing!** The contract tells you exactly what's available and what each variant does! 🎯

## Contracts Enable Predictable APIs 🎯

Contracts make your styling APIs **predictable and consistent**:

```typescript
import { contract } from "@use-pico/cls";

// All your buttons follow the same contract structure
const ButtonContract = contract({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
});

// Primary button - same contract, different implementation
const PrimaryButton = cls(ButtonContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-blue-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  }),
  // ... rest of implementation
}));

// Danger button - same contract, different implementation  
const DangerButton = cls(ButtonContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-red-100"],
      primary: ["bg-red-600"],
      danger: ["bg-red-700"]
    }
  }),
  // ... rest of implementation
}));

// Users get the same API for both buttons!
PrimaryButton.create(({ what }) => ({ variant: what.variant({ tone: "primary" }) }));
DangerButton.create(({ what }) => ({ variant: what.variant({ tone: "primary" }) }));
```

## The Bottom Line 💡

Contracts-first design provides:

- **Type safety** from the moment you define your structure
- **IntelliSense** that actually helps you write code
- **Consistency** across your entire design system
- **Documentation** that's always up-to-date
- **Refactoring safety** when you need to change things
- **Team collaboration** with clear contracts

It might seem like "extra work" to define contracts upfront, but it **saves massive amounts of time** by preventing errors, providing perfect autocomplete, and ensuring consistency across your entire application! 🚀

The contract is your **styling system's DNA** - define it once, and everything else flows naturally from there! ✨

---

**Previous:** [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md) | **Next:** [2.3 Token-Centric Design](./2.3-token-centric-design.md)
