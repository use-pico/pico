# 2.1 Callbacks Everywhere

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md) *(current)*
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

If you've used CLS for more than 5 minutes, you've probably noticed something: **there are callbacks everywhere!** 🎯

```typescript
// Definition callback
const ButtonCls = cls(contract, ({ what, def }) => ({ ... }));

// Create callbacks
const classes = ButtonCls.create(({ what }) => ({ ... }));

// Slot callbacks
const rootClasses = classes.root(({ what }) => ({ ... }));
```

At first glance, this might seem like overkill. But there's a **method to this callback madness**! Let's dive into why CLS embraces callbacks so enthusiastically! 🚀

## The Callback Philosophy 🧠

CLS uses callbacks for one simple reason: **they provide the best developer experience**. Here's why:

### 1. **Type Safety at Every Level** 🛡️

Callbacks give us access to **contextual type information** at the exact moment we need it:

```typescript
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
}, ({ what, def }) => {
  // TypeScript knows exactly what tokens, slots, and variants are available
  // 'what' and 'def' are fully typed based on the contract above
  return {
    token: def.token({
      "color.bg": {
        default: ["bg-gray-100"],
        primary: ["bg-blue-600"],
        danger: ["bg-red-500"]
      }
    }),
    rules: [
      def.root({
        root: what.both(["inline-flex", "items-center"], ["color.bg.default"]),
        label: what.css(["font-medium"])
      })
    ],
    defaults: def.defaults({
      size: "md",
      tone: "default"
    })
  };
});
```

**The magic?** TypeScript provides **perfect IntelliSense** for `what`, `def`, and all their methods because it knows the exact contract structure! ✨

### 2. **Lazy Evaluation** ⚡

Callbacks enable **lazy evaluation** - nothing is computed until it's actually needed:

```typescript
// This doesn't compute anything yet
const ButtonCls = cls(contract, ({ what, def }) => ({ ... }));

// This creates the instance but doesn't compute classes
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));

// Only NOW does CLS actually compute the classes
const rootClasses = classes.root(); // "inline-flex items-center bg-blue-600"
```

This means:
- **No wasted computation** for unused slots
- **Better performance** in complex applications
- **Memory efficiency** - only compute what you need

### 3. **Contextual Helpers** 🛠️

Each callback receives **contextual helpers** that make sense for that specific use case:

```typescript
// Definition callback gets 'what' and 'def' helpers
cls(contract, ({ what, def }) => ({ ... }));

// Create callback gets 'what' and 'override' helpers
ButtonCls.create(({ what, override }) => ({ ... }));

// Slot callback gets 'what' helper
classes.root(({ what }) => ({ ... }));
```

**Each helper is perfectly typed** for its context:
- `what` - Styling helpers (`css`, `token`, `both`, `variant`)
- `def` - Definition helpers (`root`, `rule`, `token`, `defaults`)
- `override` - Override helpers (`root`, `rule`, `token`)

## The Alternative (And Why It's Worse) 😱

Without callbacks, we'd have to do something like this:

```typescript
// ❌ The "traditional" approach (don't do this!)
const ButtonCls = cls({
  contract: { tokens: {...}, slot: [...], variant: {...} },
  definition: {
    token: { "color.bg": { default: ["bg-gray-100"], ... } },
    rules: [
      { slot: { root: { class: ["inline-flex"], token: ["color.bg.default"] } } }
    ],
    defaults: { size: "md", tone: "default" }
  }
});

// ❌ No type safety, no IntelliSense, no contextual helpers
const classes = ButtonCls.create({
  variant: { tone: "primary" } // TypeScript has no idea what's valid
});
```

**Problems with this approach:**
- **No type safety** - TypeScript can't validate variant values
- **No IntelliSense** - No autocomplete for tokens or variants
- **No contextual helpers** - You have to remember all the APIs
- **Runtime errors** - Invalid variants only fail at runtime

## Real-World Benefits 🌟

### Perfect IntelliSense
```typescript
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows exactly what's available:
    // size: "sm" | "md" | "lg"
    // tone: "default" | "primary" | "danger"
  })
}));
```

### Compile-Time Validation
```typescript
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    size: "xl" // ❌ TypeScript error: "xl" is not assignable
  })
}));
```

### Contextual APIs
```typescript
// In definition: 'def' helpers for building the definition
def.root({ root: what.css(["inline-flex"]) })

// In create: 'override' helpers for runtime overrides
override.token({ "color.bg": { primary: ["bg-purple-600"] } })
```

## The Learning Curve 📈

**Phase 1: "Why so many callbacks?"** 😰
- First encounter with the callback-heavy API
- Seems like unnecessary complexity

**Phase 2: "I see the pattern"** 🤔
- Each callback has a specific purpose
- TypeScript guides you through each one

**Phase 3: "This is actually brilliant"** 😌
- Perfect IntelliSense everywhere
- Compile-time validation catches all errors
- Contextual helpers make sense

**Phase 4: "I can't go back"** 🚀
- Other styling libraries feel primitive
- Type safety becomes addictive

## The Bottom Line 💡

CLS uses callbacks everywhere because they provide:

- **Perfect type safety** at every level
- **Lazy evaluation** for better performance
- **Contextual helpers** that make sense
- **Compile-time validation** instead of runtime errors
- **IntelliSense** that actually helps

It might seem like "callback hell" at first, but once you experience the **developer experience benefits**, you'll never want to go back to string-based styling APIs! 🎉

The callbacks aren't there to make your life harder - they're there to make your life **easier** by providing the best possible TypeScript integration and developer experience! ✨

---

**Previous:** [Chapter 1: Foundations](../01-foundations/README.md) | **Next:** [2.2 Why Contracts First](./2.2-why-contracts-first.md)
