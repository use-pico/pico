# 2.7 Performance by Design

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md) *(current)*
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

CLS isn't just type-safe and developer-friendly - it's **designed for performance** from the ground up! Every architectural decision in CLS is made with performance in mind. Let's explore how CLS achieves both developer experience and runtime performance! ⚡

## Lazy Evaluation 🦥

### Slot Function Caching

CLS uses **lazy evaluation** - nothing is computed until it's actually needed:

```typescript
// This doesn't compute anything yet
const ButtonCls = cls(contract, definition);

// This creates the instance but doesn't compute classes
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));

// Only NOW does CLS actually compute the classes
const rootClasses = classes.root(); // "inline-flex items-center bg-blue-600"
const labelClasses = classes.label(); // "font-medium"
```

**The magic?** Each slot function is **computed once and cached** for that specific configuration! 🎯

### Proxy-Based Slot Access

CLS uses **Proxy objects** for efficient slot access:

```typescript
// Slots are created on-demand via Proxy
const classes = ButtonCls.create(config);

// This creates the slot function only when accessed
const rootClasses = classes.root(); // Slot function created and cached

// Subsequent calls with same config are near-zero cost
const rootClasses2 = classes.root(); // Returns cached result
```

## Token Resolution Optimization 🏷️

### Pre-computed Token Index

CLS builds a **token index** once per contract, not per usage:

```typescript
// CLS pre-computes token resolution tables
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  })
}));

// Token resolution is O(1) lookup, not O(n) search
const classes = what.token(["color.bg.primary"]); // Instant lookup
```

### Inheritance Chain Optimization

CLS optimizes inheritance chains for efficient token resolution:

```typescript
// CLS builds inheritance chains once, not per usage
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);

// Inheritance chain is pre-computed and cached
// Token resolution walks the chain efficiently
```

## Memory Management 🧠

### Shared References

CLS shares references where possible to minimize memory usage:

```typescript
// Contracts and definitions are shared across instances
const ButtonCls = cls(contract, definition);
const PrimaryButton = ButtonCls.extend(primaryContract, primaryDefinition);

// Contract and definition objects are shared
// Only new data is allocated
```

### Minimal Closures

CLS minimizes closure creation for better performance:

```typescript
// CLS reuses helper functions instead of creating new closures
const whatUtil = what<TContract>(); // Shared across all instances

// Slot functions reuse the same whatUtil
// No new closures created per slot
```

## Runtime Performance Metrics 📊

### Zero Runtime Overhead

CLS has **minimal runtime overhead**:

```typescript
// CLS just generates class strings - no runtime magic
const classes = ButtonCls.create(config);
const rootClasses = classes.root(); // Returns string, not object

// No runtime style injection
// No CSS-in-JS overhead
// No virtual DOM diffing
```

### Efficient Class Merging

CLS uses **tailwind-merge** for optimal class output:

```typescript
// CLS deduplicates and optimizes class strings
const classes = what.both(
  ["inline-flex", "items-center"],
  ["inline-flex", "justify-center"] // "inline-flex" is deduplicated
);
// Result: "inline-flex items-center justify-center"
```

## The Alternative: Heavy Runtime Systems 😱

Without performance-by-design, you'd have **significant runtime overhead**:

```typescript
// ❌ CSS-in-JS approach (don't do this!)
const Button = styled.button`
  display: inline-flex;
  align-items: center;
  padding: ${props => props.size === 'lg' ? '1.5rem' : '0.75rem'};
  background: ${props => props.tone === 'primary' ? '#3b82f6' : '#f3f4f6'};
  color: ${props => props.tone === 'primary' ? 'white' : '#111827'};
`;

// Problems:
// - Runtime style injection
// - CSS-in-JS overhead
// - Dynamic style generation
// - Bundle size bloat
// - Performance impact on every render
```

## Real-World Performance Benefits 🌟

### 1. **Fast Component Rendering**
```typescript
// CLS generates classes once, reuses them
const Button = ({ variant, children }) => {
  const classes = ButtonCls.create(({ what }) => ({
    variant: what.variant(variant)
  }));
  
  return <button className={classes.root()}>{children}</button>;
};

// No runtime style computation on every render
// Classes are pre-computed and cached
```

### 2. **Efficient Bundle Size**
```typescript
// CLS is tiny - just class string generation
// No CSS-in-JS runtime
// No style injection overhead
// Minimal bundle impact
```

### 3. **Scalable Performance**
```typescript
// Performance scales with usage
// More components = more caching benefits
// No performance degradation with scale
```

## Performance Best Practices 💡

### 1. **Reuse CLS Instances**
```typescript
// Create CLS instances once, reuse them
const ButtonCls = cls(contract, definition);

// Don't recreate on every render
const Button = ({ variant }) => {
  const classes = ButtonCls.create(({ what }) => ({
    variant: what.variant(variant)
  }));
  return <button className={classes.root()}>Click me</button>;
};
```

### 2. **Leverage Caching**
```typescript
// CLS caches slot results automatically
const classes = ButtonCls.create(config);

// Multiple calls with same config are free
const root1 = classes.root();
const root2 = classes.root(); // Cached result
```

### 3. **Use Efficient Token Resolution**
```typescript
// Use tokens instead of direct classes for better performance
const classes = what.token(["color.bg.primary"]); // O(1) lookup
// vs
const classes = what.css(["bg-blue-600"]); // Direct class
```

## The Bottom Line 💡

Performance by design provides:

- **Lazy evaluation** - compute only what you need
- **Efficient caching** - reuse computed results
- **Minimal runtime overhead** - just class string generation
- **Scalable performance** - benefits increase with usage
- **Optimized memory usage** - shared references and minimal allocations
- **Fast token resolution** - O(1) lookups with pre-computed indices

CLS proves that you can have **both** developer experience and performance - it's not a trade-off! 🎉

Think of CLS as a **"performance-first"** styling system that happens to be incredibly developer-friendly! ⚡

---

**Previous:** [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md) | **Next:** [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
