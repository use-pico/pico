# 2.3 Token-Centric Design

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md) *(current)*
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

In CLS, **tokens are king**! üëë But what exactly are tokens, and why do they deserve such royal treatment? Let's dive into the philosophy behind token-centric design and why it's the secret sauce of CLS! üéØ

## What Are Tokens? üè∑Ô∏è

Tokens are **named design values** that represent the building blocks of your design system. Think of them as the **"atoms"** of your styling universe:

```typescript
import { contract } from "@use-pico/cls";

const ThemeContract = contract({
  tokens: {
    "color.text": ["default", "primary", "secondary", "danger"],
    "color.bg": ["default", "primary", "secondary", "danger"],
    "spacing.padding": ["sm", "md", "lg"],
    "border.radius": ["sm", "md", "lg"]
  }
});
```

Each token is like a **variable** that holds a specific design value:
- `"color.text.primary"` ‚Üí `["text-blue-600"]`
- `"spacing.padding.md"` ‚Üí `["px-4", "py-2"]`
- `"border.radius.lg"` ‚Üí `["rounded-lg"]`

## Why Tokens Are Central üéØ

### 1. **Design System Foundation** üèóÔ∏è

Tokens are the **foundation** of your entire design system. Everything else builds on top of them:

```typescript
import { cls } from "@use-pico/cls";

// Start with tokens only - your design system foundation
const ThemeCls = cls(ThemeContract, ({ what, def }) => ({
  token: def.token({
    "color.text": {
      default: ["text-gray-900"],
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      danger: ["text-red-600"]
    },
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-500"],
      danger: ["bg-red-500"]
    },
    "spacing.padding": {
      sm: ["px-2", "py-1"],
      md: ["px-4", "py-2"],
      lg: ["px-6", "py-3"]
    },
    "border.radius": {
      sm: ["rounded"],
      md: ["rounded-md"],
      lg: ["rounded-lg"]
    }
  }),
  rules: [],
  defaults: def.defaults({})
}));
```

**The magic?** Once you define these tokens, **every component** in your app can use them consistently! ‚ú®

### 2. **Semantic Design Values** üß†

Tokens provide **semantic meaning** instead of arbitrary values:

```typescript
// ‚ùå Without tokens - arbitrary values everywhere
const buttonClasses = "bg-blue-600 text-white px-4 py-2 rounded-md";

// ‚úÖ With tokens - semantic, meaningful values
const buttonClasses = what.token(["color.bg.primary", "color.text.primary", "spacing.padding.md", "border.radius.md"]);
```

**The difference?** 
- `"bg-blue-600"` tells you nothing about its purpose
- `"color.bg.primary"` tells you it's the primary background color

### 3. **Consistency Across Components** üîÑ

Tokens ensure **perfect consistency** across your entire application:

```typescript
// Button uses tokens
const ButtonCls = ThemeCls.extend(ButtonContract, ({ what, def }) => ({
  rules: [
    def.root({
      root: what.token(["color.bg.primary", "color.text.primary", "spacing.padding.md"])
    })
  ]
}));

// Card uses the same tokens
const CardCls = ThemeCls.extend(CardContract, ({ what, def }) => ({
  rules: [
    def.root({
      root: what.token(["color.bg.default", "border.radius.md"])
    })
  ]
}));

// Alert uses the same tokens
const AlertCls = ThemeCls.extend(AlertContract, ({ what, def }) => ({
  rules: [
    def.root({
      root: what.token(["color.bg.danger", "color.text.danger", "spacing.padding.md"])
    })
  ]
}));
```

**The result?** All components use the **exact same design values**! üéØ

## Token Inheritance and Overrides üß¨

Tokens support **inheritance** and **overrides**, making them incredibly flexible:

```typescript
// Base theme with tokens
const ThemeCls = cls(ThemeContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  })
}));

// Button extends theme and overrides tokens
const ButtonCls = ThemeCls.extend(ButtonContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-700"], // Override the theme's primary
      danger: ["bg-red-600"]    // Override the theme's danger
    }
  })
}));

// Usage - gets the overridden values
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));
// Result: "bg-blue-700" (not "bg-blue-600")
```

## Runtime Token Overrides üé®

Tokens can be **overridden at runtime** for specific use cases:

```typescript
// Override tokens for a specific button
const customButton = ButtonCls.create(({ what, override }) => ({
  variant: what.variant({ tone: "primary" }),
  token: override.token({
    "color.bg": {
      primary: ["bg-purple-600"] // Override with purple for this instance
    }
  })
}));

// Use it
<button className={customButton.root()}>Purple Button</button>
```

This gives you **incredible flexibility** while maintaining type safety! üöÄ

## The Alternative: Direct CSS Classes üò±

Without tokens, you end up with **inconsistent, hard-to-maintain** styling:

```typescript
// ‚ùå The "traditional" way (don't do this!)
const ButtonStyles = {
  primary: "bg-blue-600 text-white px-4 py-2 rounded-md",
  danger: "bg-red-500 text-white px-4 py-2 rounded-md",
  secondary: "bg-gray-500 text-white px-4 py-2 rounded-md"
};

const CardStyles = {
  default: "bg-white text-gray-900 p-4 rounded-md", // Different padding!
  elevated: "bg-white text-gray-900 p-6 rounded-lg" // Different radius!
};

const AlertStyles = {
  error: "bg-red-100 text-red-800 p-4 rounded", // Different colors!
  success: "bg-green-100 text-green-800 p-4 rounded" // Different colors!
};
```

**Problems with this approach:**
- **Inconsistent values** - different padding, colors, radius across components
- **Hard to maintain** - change a color, update 47 different places
- **No semantic meaning** - just arbitrary CSS classes
- **No type safety** - typos only caught at runtime

## Real-World Benefits üåü

### 1. **Design System Consistency**
```typescript
// One token change updates everything
const ThemeCls = cls(ThemeContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-indigo-600"], // Changed from blue to indigo
      // All components using "color.bg.primary" automatically update!
    }
  })
}));
```

### 2. **Semantic Design Language**
```typescript
// Your design tokens become a language
const buttonClasses = what.token([
  "color.bg.primary",    // "Use the primary background"
  "color.text.primary",  // "Use the primary text color"
  "spacing.padding.md",  // "Use medium padding"
  "border.radius.md"     // "Use medium border radius"
]);
```

### 3. **Type-Safe Design Values**
```typescript
// TypeScript ensures you only use valid tokens
const buttonClasses = what.token([
  "color.bg.primary",    // ‚úÖ Valid token
  "color.text.primary",  // ‚úÖ Valid token
  "spacing.padding.md"   // ‚úÖ Valid token
]);

// Invalid tokens cause compile-time errors
const buttonClasses = what.token([
  "color.bg.purple",     // ‚ùå Error: "purple" not in contract
  "spacing.padding.xl"   // ‚ùå Error: "xl" not in contract
]);
```

## The Bottom Line üí°

Token-centric design provides:

- **Consistency** across your entire design system
- **Semantic meaning** instead of arbitrary values
- **Type safety** for all design values
- **Inheritance and overrides** for flexibility
- **Runtime customization** when needed
- **Maintainability** - change once, update everywhere

Tokens aren't just a feature of CLS - they're the **heart and soul** of the system! They transform your styling from a collection of arbitrary CSS classes into a **coherent, semantic design language** that's consistent, maintainable, and type-safe! üéâ

Think of tokens as your **design system's vocabulary** - once you learn the language, everything becomes clear, consistent, and predictable! ‚ú®

---

**Previous:** [2.2 Why Contracts First](./2.2-why-contracts-first.md) | **Next:** [2.4 Rule-Based System](./2.4-rule-based-system.md)
