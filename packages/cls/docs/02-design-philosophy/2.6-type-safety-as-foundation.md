# 2.6 Type Safety as Foundation

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md) *(current)*
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

Type safety isn't just a feature of CLS - it's the **foundation** that everything else is built upon. From contracts to tokens to variants, every aspect of CLS is designed with type safety in mind from day one! ðŸ›¡ï¸

## Type Safety Everywhere ðŸŽ¯

### 1. **Contract Type Safety** ðŸ“‹

Contracts are **fully typed** from the moment you define them:

```typescript
import { contract } from "@use-pico/cls";

const ButtonContract = contract({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
});

// TypeScript knows exactly what's in this contract
// - Tokens: "color.bg.default" | "color.bg.primary" | "color.bg.danger" | ...
// - Slots: "root" | "label"
// - Variants: { size: "sm" | "md" | "lg", tone: "default" | "primary" | "danger" }
```

### 2. **Token Type Safety** ðŸ·ï¸

Tokens are **type-safe** throughout your entire application:

```typescript
import { cls } from "@use-pico/cls";

const ButtonCls = cls(ButtonContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  }),
  rules: [
    def.root({
      // TypeScript ensures you only use valid tokens
      root: what.token([
        "color.bg.primary",    // âœ… Valid
        "color.text.primary",  // âœ… Valid
        "color.bg.invalid"     // âŒ TypeScript error!
      ])
    })
  ]
}));
```

### 3. **Variant Type Safety** ðŸŽ›ï¸

Variants are **compile-time validated**:

```typescript
// TypeScript ensures only valid variants are used
ButtonCls.create(({ what }) => ({
  variant: what.variant({
    size: "lg",        // âœ… Valid
    tone: "primary",   // âœ… Valid
    size: "xl",        // âŒ TypeScript error: "xl" not in contract
    tone: "purple"     // âŒ TypeScript error: "purple" not in contract
  })
}));
```

## Type Inference Magic âœ¨

CLS uses **advanced TypeScript features** to provide perfect type inference:

### Automatic Type Inference

```typescript
// TypeScript automatically infers types from your contract
const ButtonCls = cls(ButtonContract, ({ what, def }) => ({
  // TypeScript knows exactly what tokens, slots, and variants are available
  // No manual type annotations needed!
}));

// The resulting ButtonCls is fully typed
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // IntelliSense shows: size: "sm" | "md" | "lg"
    // IntelliSense shows: tone: "default" | "primary" | "danger"
  })
}));
```

### Generic Type Constraints

```typescript
// CLS uses generics to ensure type safety across inheritance
const ThemeCls = cls(ThemeContract, definition);
const ButtonCls = ThemeCls.extend(ButtonContract, definition);

// TypeScript ensures ButtonCls inherits from ThemeCls correctly
// All theme tokens are available in ButtonCls
// All theme variants are available in ButtonCls
```

## The Alternative: String-Based APIs ðŸ˜±

Without type safety, you'd have **runtime errors and poor DX**:

```typescript
// âŒ The "traditional" way (don't do this!)
const ButtonCls = {
  create: (variants) => {
    // No type checking - anything goes!
    const { size, tone } = variants;
    
    // Runtime errors if variants are invalid
    if (!["sm", "md", "lg"].includes(size)) {
      throw new Error(`Invalid size: ${size}`);
    }
    
    if (!["default", "primary", "danger"].includes(tone)) {
      throw new Error(`Invalid tone: ${tone}`);
    }
    
    // String concatenation - prone to typos
    return `button button--${size} button--${tone}`;
  }
};

// Runtime errors only discovered when code runs
ButtonCls.create({ size: "xl", tone: "purple" }); // ðŸ’¥ Runtime error!
```

**Problems with string-based APIs:**
- **Runtime errors** instead of compile-time errors
- **No IntelliSense** - you have to remember everything
- **Typos** that only surface at runtime
- **Poor refactoring support** - hard to find all usages
- **Inconsistent APIs** - no guarantee of structure

## Real-World Benefits ðŸŒŸ

### 1. **Catch Errors Early**
```typescript
// TypeScript catches errors at compile time
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    size: "xl" // âŒ Compile-time error: "xl" not in contract
  })
}));
```

### 2. **Perfect IntelliSense**
```typescript
// TypeScript provides perfect autocomplete
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // IntelliSense shows all valid options
    size: "sm" | "md" | "lg",
    tone: "default" | "primary" | "danger"
  })
}));
```

### 3. **Safe Refactoring**
```typescript
// TypeScript ensures refactoring is safe
const ButtonContract = contract({
  variant: {
    size: ["sm", "md", "lg"],
    // tone: ["default", "primary", "danger"] // Old
    variant: ["default", "primary", "danger"] // New
  }
});

// TypeScript shows all places that need updating
ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" }) // âŒ Error: 'tone' doesn't exist
}));
```

## Type Safety Best Practices ðŸ’¡

### 1. **Use TypeScript Strict Mode**
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

### 2. **Leverage Type Inference**
```typescript
// Let TypeScript infer types - don't add unnecessary annotations
const ButtonCls = cls(ButtonContract, ({ what, def }) => ({
  // TypeScript knows the types from the contract
}));
```

### 3. **Use Type-Safe Helpers**
```typescript
// Use CLS helpers for type safety
const classes = ButtonCls.create(({ what, override }) => ({
  variant: what.variant({ size: "lg" }), // Type-safe variants
  token: override.token({ "color.bg": { primary: ["bg-purple-600"] } }) // Type-safe tokens
}));
```

## The Bottom Line ðŸ’¡

Type safety as foundation provides:

- **Compile-time error detection** instead of runtime errors
- **Perfect IntelliSense** with autocomplete everywhere
- **Safe refactoring** with TypeScript guidance
- **Consistent APIs** enforced by the type system
- **Better developer experience** with confidence
- **Reduced bugs** through compile-time validation

Type safety isn't just a nice-to-have in CLS - it's the **bedrock** that makes everything else possible! ðŸŽ‰

Think of type safety as your **"safety net"** - it catches errors before they reach production and guides you to write correct code! âœ¨

---

**Previous:** [2.5 Required Defaults](./2.5-required-defaults.md) | **Next:** [2.7 Performance by Design](./2.7-performance-by-design.md)
