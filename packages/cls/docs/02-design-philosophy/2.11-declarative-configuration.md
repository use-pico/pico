# 2.11 Declarative Configuration

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md) *(current)*

---

CLS is built around **declarative configuration** - you describe **what** you want, not **how** to achieve it. This makes your styling code more readable, maintainable, and expressive. Let's explore how CLS embraces declarative patterns! 🎯

## What is Declarative Configuration? 📋

### Declarative vs Imperative

**Declarative** means describing **what** you want:
```typescript
// Declarative: "I want a primary button with large size"
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  }),
  rules: [
    def.rule(
      what.variant({ tone: "primary" }),
      { root: what.token(["color.bg.primary"]) }
    ),
    def.rule(
      what.variant({ size: "lg" }),
      { root: what.css(["px-6", "py-3"]) }
    )
  ]
}));
```

**Imperative** means describing **how** to achieve it:
```typescript
// Imperative: "Check if tone is primary, then apply blue background"
function getButtonClasses(variants) {
  let classes = "inline-flex items-center rounded";
  
  if (variants.tone === "primary") {
    classes += " bg-blue-600";
  } else if (variants.tone === "danger") {
    classes += " bg-red-500";
  }
  
  if (variants.size === "lg") {
    classes += " px-6 py-3";
  }
  
  return classes;
}
```

## Declarative Patterns in CLS 🎨

### 1. **Declarative Contracts**

Contracts declare **what** your module can do:

```typescript
import { contract } from "@use-pico/cls";

// Declarative: "This button has these tokens, slots, and variants"
const ButtonContract = contract({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"],
    "spacing.padding": ["sm", "md", "lg"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
});

// The contract declares the structure, not the implementation
```

### 2. **Declarative Tokens**

Tokens declare **what** design values are available:

```typescript
// Declarative: "These are the available design tokens"
token: def.token({
  "color.bg": {
    default: ["bg-gray-100"],
    primary: ["bg-blue-600"],
    danger: ["bg-red-500"]
  },
  "color.text": {
    default: ["text-gray-900"],
    primary: ["text-white"],
    danger: ["text-white"]
  },
  "spacing.padding": {
    sm: ["px-2", "py-1"],
    md: ["px-4", "py-2"],
    lg: ["px-6", "py-3"]
  }
});
```

### 3. **Declarative Rules**

Rules declare **what** happens when conditions are met:

```typescript
// Declarative: "When tone is primary, use primary colors"
rules: [
  def.rule(
    what.variant({ tone: "primary" }),
    { root: what.token(["color.bg.primary", "color.text.primary"]) }
  ),
  def.rule(
    what.variant({ size: "lg" }),
    { root: what.token(["spacing.padding.lg"]) }
  ),
  def.rule(
    what.variant({ disabled: true }),
    { root: what.css(["opacity-50", "cursor-not-allowed"]) }
  )
];
```

### 4. **Declarative Defaults**

Defaults declare **what** the base state should be:

```typescript
// Declarative: "The default state is medium size with default tone"
defaults: def.defaults({
  size: "md",
  tone: "default"
});
```

## Declarative vs Imperative Examples 📊

### Button Styling

**Declarative (CLS):**
```typescript
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    }
  }),
  rules: [
    def.rule(
      what.variant({ tone: "primary" }),
      { root: what.token(["color.bg.primary"]) }
    ),
    def.rule(
      what.variant({ tone: "danger" }),
      { root: what.token(["color.bg.danger"]) }
    )
  ]
}));
```

**Imperative (Traditional):**
```typescript
function getButtonClasses(variants) {
  let classes = "inline-flex items-center rounded";
  
  if (variants.tone === "primary") {
    classes += " bg-blue-600";
  } else if (variants.tone === "danger") {
    classes += " bg-red-500";
  }
  
  return classes;
}
```

### Theme Configuration

**Declarative (CLS):**
```typescript
const ThemeCls = cls(themeContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      secondary: ["bg-gray-500"],
      danger: ["bg-red-500"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      secondary: ["text-gray-600"],
      danger: ["text-red-600"]
    }
  })
}));
```

**Imperative (Traditional):**
```typescript
const theme = {
  getBackgroundColor: (variant) => {
    switch (variant) {
      case "primary": return "#3b82f6";
      case "secondary": return "#6b7280";
      case "danger": return "#ef4444";
      default: return "#f3f4f6";
    }
  },
  getTextColor: (variant) => {
    switch (variant) {
      case "primary": return "#3b82f6";
      case "secondary": return "#6b7280";
      case "danger": return "#ef4444";
      default: return "#111827";
    }
  }
};
```

## Benefits of Declarative Configuration 🌟

### 1. **Readability**

Declarative code reads like **documentation**:

```typescript
// Reads like: "This button has primary and danger tones"
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"], // Primary tone uses blue background
      danger: ["bg-red-500"]    // Danger tone uses red background
    }
  }),
  rules: [
    def.rule(
      what.variant({ tone: "primary" }), // When tone is primary
      { root: what.token(["color.bg.primary"]) } // Use primary colors
    )
  ]
}));
```

### 2. **Maintainability**

Declarative code is **easy to modify**:

```typescript
// Easy to add new variants
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"],
      success: ["bg-green-500"] // Easy to add
    }
  }),
  rules: [
    def.rule(
      what.variant({ tone: "primary" }),
      { root: what.token(["color.bg.primary"]) }
    ),
    def.rule(
      what.variant({ tone: "danger" }),
      { root: what.token(["color.bg.danger"]) }
    ),
    def.rule(
      what.variant({ tone: "success" }), // Easy to add
      { root: what.token(["color.bg.success"]) }
    )
  ]
}));
```

### 3. **Expressiveness**

Declarative code **expresses intent** clearly:

```typescript
// Clear intent: "This is a button with size and tone variants"
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "spacing.padding": ["sm", "md", "lg"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],     // Intent: Button has size variants
    tone: ["default", "primary", "danger"] // Intent: Button has tone variants
  }
}, ({ what, def }) => ({
  // Implementation follows the declared structure
}));
```

## The Alternative: Imperative Configuration 😱

Without declarative configuration, you'd have **imperative, hard-to-read code**:

```typescript
// ❌ Imperative configuration (don't do this!)
class ButtonStyler {
  constructor() {
    this.variants = new Map();
    this.tokens = new Map();
  }
  
  addVariant(name, values) {
    this.variants.set(name, values);
  }
  
  addToken(name, values) {
    this.tokens.set(name, values);
  }
  
  generateClasses(config) {
    let classes = "";
    
    // Imperative logic for generating classes
    for (const [variantName, variantValue] of Object.entries(config)) {
      const variant = this.variants.get(variantName);
      if (variant && variant.includes(variantValue)) {
        const token = this.tokens.get(`${variantName}.${variantValue}`);
        if (token) {
          classes += " " + token;
        }
      }
    }
    
    return classes.trim();
  }
}

// Usage is imperative and hard to understand
const buttonStyler = new ButtonStyler();
buttonStyler.addVariant("tone", ["default", "primary", "danger"]);
buttonStyler.addToken("tone.primary", "bg-blue-600");
buttonStyler.addToken("tone.danger", "bg-red-500");

const classes = buttonStyler.generateClasses({ tone: "primary" });
```

## Real-World Benefits 🌟

### 1. **Self-Documenting Code**
```typescript
// The code documents itself
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"], // Available background colors
    "spacing.padding": ["sm", "md", "lg"]         // Available padding sizes
  },
  variant: {
    size: ["sm", "md", "lg"],     // Size variants
    tone: ["default", "primary", "danger"] // Tone variants
  }
}, ({ what, def }) => ({
  // Implementation follows the declared structure
}));
```

### 2. **Easy Refactoring**
```typescript
// Easy to refactor - just update the declarations
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger", "success"], // Added success
    "spacing.padding": ["sm", "md", "lg", "xl"]             // Added xl
  },
  variant: {
    size: ["sm", "md", "lg", "xl"],     // Added xl
    tone: ["default", "primary", "danger", "success"] // Added success
  }
}, ({ what, def }) => ({
  // Implementation automatically supports new variants
}));
```

### 3. **Consistent Patterns**
```typescript
// All components follow the same declarative pattern
const CardCls = cls(cardContract, ({ what, def }) => ({
  token: def.token({ /* tokens */ }),
  rules: [ /* rules */ ],
  defaults: def.defaults({ /* defaults */ })
}));

const ModalCls = cls(modalContract, ({ what, def }) => ({
  token: def.token({ /* tokens */ }),
  rules: [ /* rules */ ],
  defaults: def.defaults({ /* defaults */ })
}));
```

## Declarative Configuration Best Practices 💡

### 1. **Be Explicit**
```typescript
// Explicit declarations are better than implicit ones
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"], // Explicit token names
    "color.text": ["default", "primary", "danger"] // Explicit token names
  },
  variant: {
    size: ["sm", "md", "lg"],     // Explicit variant names
    tone: ["default", "primary", "danger"] // Explicit variant names
  }
}, ({ what, def }) => ({
  // Implementation follows explicit declarations
}));
```

### 2. **Use Descriptive Names**
```typescript
// Descriptive names make declarations clearer
const ButtonCls = cls({
  tokens: {
    "color.background": ["default", "primary", "danger"], // Clear naming
    "color.text": ["default", "primary", "danger"],       // Clear naming
    "spacing.padding": ["small", "medium", "large"]       // Clear naming
  },
  variant: {
    size: ["small", "medium", "large"],     // Clear naming
    tone: ["default", "primary", "danger"]  // Clear naming
  }
}, ({ what, def }) => ({
  // Implementation follows clear naming
}));
```

### 3. **Group Related Declarations**
```typescript
// Group related declarations together
const ButtonCls = cls({
  tokens: {
    // Color-related tokens
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"],
    "color.border": ["default", "primary", "danger"],
    
    // Spacing-related tokens
    "spacing.padding": ["sm", "md", "lg"],
    "spacing.margin": ["sm", "md", "lg"],
    
    // Typography-related tokens
    "typography.size": ["sm", "md", "lg"],
    "typography.weight": ["normal", "medium", "bold"]
  },
  variant: {
    // Appearance variants
    tone: ["default", "primary", "danger"],
    variant: ["solid", "outline", "ghost"],
    
    // Size variants
    size: ["sm", "md", "lg"]
  }
}, ({ what, def }) => ({
  // Implementation follows grouped declarations
}));
```

## The Bottom Line 💡

Declarative configuration provides:

- **Readable code** that reads like documentation
- **Maintainable code** that's easy to modify and extend
- **Expressive code** that clearly communicates intent
- **Self-documenting code** that explains itself
- **Consistent patterns** across all components
- **Better developer experience** with clear, predictable APIs

CLS proves that **declarative configuration** makes styling code more readable, maintainable, and expressive! 🎉

Think of declarative configuration as **"writing requirements, not implementation"** - you describe what you want, and CLS figures out how to achieve it! ✨

---

**Previous:** [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md) | **Next:** [3.1 Core API Overview](../03-core-api/3.1-core-api-overview.md)
