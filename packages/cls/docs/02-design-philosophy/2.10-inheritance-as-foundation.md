# 2.10 Inheritance as Foundation

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md) *(current)*
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

CLS is **fundamentally built on inheritance and extensions**! The `.extend()` method is the core mechanism for building complex styling systems. While composition can be used within definitions, inheritance is the primary architectural pattern in CLS. Let's explore how CLS leverages inheritance effectively! 🎯

## The Inheritance Philosophy 🧬

### What is Inheritance in CLS?

Inheritance in CLS means **building complex styling systems by extending base modules**:

```typescript
// Build through inheritance - extend base modules
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, ({ what, def }) => ({
  // Inherit all theme tokens and add button-specific ones
  token: def.token({
    // Theme tokens are automatically inherited
    // Add button-specific tokens
    "button.variant": ["solid", "outline", "ghost"]
  }),
  rules: [
    // Theme rules are automatically inherited
    // Add button-specific rules
    def.rule(
      what.variant({ variant: "outline" }),
      { root: what.css(["border", "border-gray-300"]) }
    )
  ],
  defaults: def.defaults({
    // Theme defaults are automatically inherited
    variant: "solid"
  })
}));
```

## Inheritance vs Composition 📊

### Inheritance Approach (Primary)

```typescript
// Build through inheritance - the CLS way
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const PrimaryButton = ButtonCls.extend(primaryContract, primaryDefinition);

// Benefits:
// - Automatic token inheritance
// - Automatic rule inheritance
// - Automatic default inheritance
// - Type-safe inheritance chain
// - Clear parent-child relationships
```

### Composition Approach (Within Definitions)

```typescript
// Composition can be used within definitions
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    // Compose tokens within the definition
    ...colorTokens,
    ...spacingTokens,
    ...typographyTokens
  }),
  rules: [
    // Compose rules within the definition
    ...baseRules,
    ...colorRules,
    ...spacingRules
  ]
}));

// But inheritance is still the primary pattern
const ExtendedButton = ButtonCls.extend(extendedContract, extendedDefinition);
```

## Inheritance Patterns 🎨

### 1. **Token Inheritance**

Inherit tokens from parent modules:

```typescript
// Define base tokens in parent module
const ThemeCls = cls(themeContract, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"],
      success: ["bg-green-500"]
    },
    "color.text": {
      primary: ["text-blue-600"],
      danger: ["text-red-500"],
      success: ["text-green-500"]
    },
    "spacing.padding": {
      sm: ["px-2", "py-1"],
      md: ["px-4", "py-2"],
      lg: ["px-6", "py-3"]
    }
  })
}));

// Inherit tokens and add button-specific ones
const ButtonCls = ThemeCls.extend(buttonContract, ({ what, def }) => ({
  token: def.token({
    // All theme tokens are automatically inherited
    // Add button-specific tokens
    "button.variant": {
      solid: ["border-transparent"],
      outline: ["border", "bg-transparent"]
    }
  })
}));
```

### 2. **Rule Inheritance**

Inherit rules from parent modules:

```typescript
// Define base rules in parent module
const ThemeCls = cls(themeContract, ({ what, def }) => ({
  rules: [
    def.root({
      root: what.css(["inline-flex", "items-center", "rounded"])
    }),
    def.rule(
      what.variant({ tone: "primary" }),
      { root: what.token(["color.bg.primary", "color.text.primary"]) }
    ),
    def.rule(
      what.variant({ tone: "danger" }),
      { root: what.token(["color.bg.danger", "color.text.danger"]) }
    ),
    def.rule(
      what.variant({ size: "lg" }),
      { root: what.token(["spacing.padding.lg"]) }
    )
  ]
}));

// Inherit rules and add button-specific ones
const ButtonCls = ThemeCls.extend(buttonContract, ({ what, def }) => ({
  rules: [
    // All theme rules are automatically inherited
    // Add button-specific rules
    def.rule(
      what.variant({ variant: "outline" }),
      { root: what.css(["border", "border-gray-300"]) }
    )
  ]
}));
```

### 3. **Contract Inheritance**

Inherit contracts from parent modules:

```typescript
// Define base contract in parent module
const ThemeContract = {
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"],
    "spacing.padding": ["sm", "md", "lg"]
  },
  slot: ["root"],
  variant: {
    tone: ["default", "primary", "danger"],
    size: ["sm", "md", "lg"]
  }
};

// Extend contract for button-specific needs
const ButtonContract = {
  tokens: {
    // All theme tokens are inherited
    "button.variant": ["solid", "outline"]
  },
  slot: ["root", "label"], // Extend slots
  variant: {
    // All theme variants are inherited
    variant: ["solid", "outline"] // Add button-specific variants
  }
};
```

## When to Use Inheritance 🎯

### Primary Inheritance Use Cases

Inheritance is the **primary pattern** in CLS:

```typescript
// 1. Theme inheritance - extending a base theme
const ThemeCls = cls(themeContract, themeDefinition);
const BrandTheme = ThemeCls.extend(brandContract, brandDefinition);

// 2. Component family inheritance - related components
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const IconButton = ButtonCls.extend(iconButtonContract, iconButtonDefinition);

// 3. Variant inheritance - extending variant options
const BaseButton = ThemeCls.extend(baseButtonContract, baseButtonDefinition);
const ExtendedButton = BaseButton.extend(extendedContract, extendedDefinition);
```

### Inheritance Best Practices

```typescript
// Build inheritance chains naturally
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const PrimaryButton = ButtonCls.extend(primaryContract, primaryDefinition);

// Use inheritance for "is-a" relationships
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const IconButton = ButtonCls.extend(iconButtonContract, iconButtonDefinition);
// IconButton IS-A ButtonCls

// Use composition within definitions for "has-a" relationships
const ButtonCls = ThemeCls.extend(buttonContract, ({ what, def }) => ({
  token: def.token({
    // Compose tokens within the definition
    ...colorTokens,
    ...spacingTokens
  })
}));
// ButtonCls HAS-A colorTokens and spacingTokens within its definition
```

## The Alternative: No Inheritance 😱

Without inheritance, you'd have **manual composition everywhere**:

```typescript
// ❌ Manual composition everywhere (don't do this!)
const ButtonCls = cls(contract, ({ what, def }) => ({
  token: def.token({
    ...ThemeCls.token,
    ...ColorCls.token,
    ...SpacingCls.token,
    ...TypographyCls.token,
    // Manual composition of everything
  }),
  rules: [
    ...ThemeCls.rules,
    ...ColorCls.rules,
    ...SpacingCls.rules,
    ...TypographyCls.rules,
    // Manual composition of everything
  ],
  defaults: def.defaults({
    ...ThemeCls.defaults,
    ...ColorCls.defaults,
    ...SpacingCls.defaults,
    ...TypographyCls.defaults,
    // Manual composition of everything
  })
}));

// Problems:
// - Manual composition everywhere
// - No automatic inheritance
// - Repetitive code
// - Hard to maintain
// - No clear parent-child relationships
```

## Real-World Benefits 🌟

### 1. **Automatic Inheritance**
```typescript
// Inherit everything automatically
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);

// ButtonCls automatically gets all theme tokens, rules, and defaults
// No manual composition needed
```

### 2. **Clear Parent-Child Relationships**
```typescript
// Clear inheritance hierarchy
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const PrimaryButton = ButtonCls.extend(primaryContract, primaryDefinition);

// Clear chain: ThemeCls -> ButtonCls -> PrimaryButton
// Each level extends the previous one
```

### 3. **Type-Safe Inheritance**
```typescript
// TypeScript ensures inheritance is type-safe
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);

// TypeScript knows ButtonCls inherits from ThemeCls
// All theme tokens and variants are available in ButtonCls
```

## Inheritance Best Practices 💡

### 1. **Build from Base Themes**
```typescript
// Start with a comprehensive base theme
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
const CardCls = ThemeCls.extend(cardContract, cardDefinition);
```

### 2. **Use Descriptive Names**
```typescript
// Clear, descriptive names for inheritance hierarchy
const BaseTheme = cls(baseThemeContract, baseThemeDefinition);
const BrandTheme = BaseTheme.extend(brandThemeContract, brandThemeDefinition);
const ComponentTheme = BrandTheme.extend(componentThemeContract, componentThemeDefinition);
```

### 3. **Document Inheritance Patterns**
```typescript
// Document the inheritance hierarchy
const ThemeCls = cls(themeContract, themeDefinition);
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);
// ButtonCls inherits:
// - All theme tokens (color, spacing, typography)
// - All theme rules (base styles, variants)
// - All theme defaults (base variant values)
```

## The Bottom Line 💡

Inheritance provides:

- **Automatic inheritance** - tokens, rules, and defaults are inherited automatically
- **Clear hierarchy** - explicit parent-child relationships
- **Type-safe inheritance** - TypeScript ensures inheritance is correct
- **Reduced repetition** - no manual composition needed
- **Maintainable code** - changes in parent propagate to children
- **Predictable behavior** - inheritance follows clear rules

CLS proves that **inheritance is the primary pattern** - use `.extend()` to build complex systems from simple bases! 🎉

Think of inheritance as **"building a family tree"** - each level extends and builds upon the previous one! ✨

---

**Previous:** [2.9 CSS Connection](./2.9-css-connection.md) | **Next:** [2.11 Declarative Configuration](./2.11-declarative-configuration.md)
