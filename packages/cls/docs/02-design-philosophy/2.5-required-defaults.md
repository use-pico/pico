# 2.5 Required Defaults

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md) *(current)*
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

In CLS, **defaults are not optional** - they're required for every variant you define. But why? What's so important about having defaults? Let's explore the philosophy behind required defaults and why they make your styling system more predictable! 🎯

## What Are Defaults? 📋

Defaults are the **fallback values** for your variants when no specific value is provided:

```typescript
import { cls } from "@use-pico/cls";

const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],      // Three possible values
    tone: ["default", "primary", "danger"] // Three possible values
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    },
    "color.text": {
      default: ["text-gray-900"],
      primary: ["text-white"],
      danger: ["text-white"]
    }
  }),
  rules: [
    def.root({
      root: what.both(["inline-flex", "items-center", "rounded"], ["color.bg.default", "color.text.default", "spacing.padding.md"]),
      label: what.css(["font-medium"])
    })
  ],
  defaults: def.defaults({
    size: "md",     // When no size is specified, use "md"
    tone: "default" // When no tone is specified, use "default"
  })
}));
```

## Why Defaults Are Required 🎯

### 1. **Predictable Behavior** 🎯

Defaults ensure that **every component instance has a predictable state**:

```typescript
// ✅ With defaults - always predictable
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  defaults: def.defaults({
    size: "md",
    tone: "default"
  })
}));

// These all produce the same result - predictable!
const button1 = ButtonCls.create(); // Uses defaults: { size: "md", tone: "default" }
const button2 = ButtonCls.create(({ what }) => ({ variant: what.variant({}) })); // Same defaults
const button3 = ButtonCls.create(({ what }) => ({ variant: what.variant({ size: "md" }) })); // Explicit default
```

### 2. **No Undefined States** 🛡️

Without defaults, you'd have **undefined states** that could cause unpredictable behavior:

```typescript
// ❌ Without defaults - unpredictable behavior
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  // No defaults! What happens when no variants are provided?
}));

// What does this produce? Who knows!
const button = ButtonCls.create(); // Undefined state!
```

### 3. **Type Safety** 🔒

Defaults provide **type safety** by ensuring all variants have known values:

```typescript
// TypeScript knows the exact type of your variants
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  defaults: def.defaults({
    size: "md",     // TypeScript knows size is "sm" | "md" | "lg"
    tone: "default" // TypeScript knows tone is "default" | "primary" | "danger"
  })
}));

// TypeScript can provide perfect IntelliSense
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows exactly what's valid
  })
}));
```

## How Defaults Work 🔄

### Default Resolution Process

When you create a component instance, CLS resolves variants like this:

1. **Start with defaults**: `{ size: "md", tone: "default" }`
2. **Apply user variants**: `{ size: "lg" }` (user only specified size)
3. **Final state**: `{ size: "lg", tone: "default" }` (tone uses default)

```typescript
// Example: User only specifies size
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg" }) // Only size specified
}));

// CLS internally resolves to:
// { size: "lg", tone: "default" }
// Then applies rules based on this complete state
```

### Partial Overrides

You can override **some variants** while leaving others to use defaults:

```typescript
// Override only size, use default tone
const largeButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg" })
}));

// Override only tone, use default size
const primaryButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));

// Override both
const largePrimaryButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg", tone: "primary" })
}));
```

## Boolean Variant Defaults 🔘

Boolean variants also need defaults:

```typescript
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "disabled"]
  },
  slot: ["root"],
  variant: {
    disabled: ["bool"], // Boolean variant
    loading: ["bool"]   // Boolean variant
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      disabled: ["bg-gray-300"]
    }
  }),
  rules: [
    def.root({
      root: what.token(["color.bg.default"])
    }),
    def.rule(
      what.variant({ disabled: true }),
      { root: what.css(["opacity-50", "cursor-not-allowed"]) }
    ),
    def.rule(
      what.variant({ loading: true }),
      { root: what.css(["animate-pulse"]) }
    )
  ],
  defaults: def.defaults({
    disabled: false, // Default to enabled
    loading: false   // Default to not loading
  })
}));
```

## The Alternative: Optional Defaults 😱

Without required defaults, you'd have **unpredictable behavior**:

```typescript
// ❌ The "traditional" way (don't do this!)
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  // No defaults! What happens when no variants are provided?
}));

// These could all produce different results!
const button1 = ButtonCls.create(); // Maybe uses first variant value?
const button2 = ButtonCls.create(); // Maybe uses random variant value?
const button3 = ButtonCls.create(); // Maybe throws an error?

// No way to know what the "base" state should be!
```

**Problems with optional defaults:**
- **Unpredictable behavior** - different results for same input
- **No clear base state** - what does the component look like by default?
- **Type safety issues** - TypeScript can't guarantee variant values
- **Debugging nightmares** - hard to understand why styles are applied

## Real-World Benefits 🌟

### 1. **Consistent Base State**
```typescript
// Every button has a consistent base appearance
const ButtonCls = cls(contract, ({ what, def }) => ({
  defaults: def.defaults({
    size: "md",     // All buttons are medium by default
    tone: "default" // All buttons use default colors by default
  })
}));

// These all look the same by default
<ButtonCls /> // Medium, default colors
<ButtonCls tweak={() => ({})} /> // Same as above
```

### 2. **Clear API Design**
```typescript
// The API is clear about what the default behavior is
const ButtonCls = cls(contract, ({ what, def }) => ({
  defaults: def.defaults({
    size: "md",     // "Buttons are medium by default"
    tone: "default" // "Buttons use default colors by default"
  })
}));
```

### 3. **Type-Safe Variants**
```typescript
// TypeScript knows the complete variant state
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows size defaults to "md"
    // TypeScript knows tone defaults to "default"
  })
}));
```

## Best Practices for Defaults 💡

### 1. **Choose Sensible Defaults**
```typescript
defaults: def.defaults({
  size: "md",     // Most common size
  tone: "default" // Most common tone
})
```

### 2. **Document Your Defaults**
```typescript
// Clear documentation of default behavior
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... implementation ...
  defaults: def.defaults({
    size: "md",     // Default: Medium size for most use cases
    tone: "default" // Default: Neutral colors for general use
  })
}));
```

### 3. **Consider User Expectations**
```typescript
// Defaults should match user expectations
defaults: def.defaults({
  disabled: false, // Users expect buttons to be enabled by default
  loading: false,  // Users expect buttons to not be loading by default
  size: "md"       // Users expect medium size as the standard
})
```

## The Bottom Line 💡

Required defaults provide:

- **Predictable behavior** for every component instance
- **No undefined states** that could cause bugs
- **Type safety** with complete variant information
- **Clear API design** that communicates intent
- **Consistent base state** across your design system
- **Better developer experience** with reliable behavior

Defaults aren't just a convenience - they're a **fundamental requirement** for building reliable, predictable styling systems! 🎉

Think of defaults as the **"sensible starting point"** for your components - they ensure that every component instance has a well-defined, predictable state! ✨

---

**Previous:** [2.4 Rule-Based System](./2.4-rule-based-system.md) | **Next:** [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
