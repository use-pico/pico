# 2.5 Required Defaults

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md)
- [2.5 Required Defaults](./2.5-required-defaults.md) *(current)*
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

In CLS, **defaults are not optional** - they're required for every variant you define. But why? What's so important about having defaults? Let's explore the philosophy behind required defaults and why they make your styling system more predictable! ðŸŽ¯

## What Are Defaults? ðŸ“‹

Defaults are the **fallback values** for your variants when no specific value is provided:

```typescript
import { cls } from "@use-pico/cls";

const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],      // Three possible values
    tone: ["default", "primary", "danger"] // Three possible values
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    },
    "color.text": {
      default: ["text-gray-900"],
      primary: ["text-white"],
      danger: ["text-white"]
    }
  }),
  rules: [
    def.root({
      root: what.both(["inline-flex", "items-center", "rounded"], ["color.bg.default", "color.text.default", "spacing.padding.md"]),
      label: what.css(["font-medium"])
    })
  ],
  defaults: def.defaults({
    size: "md",     // When no size is specified, use "md"
    tone: "default" // When no tone is specified, use "default"
  })
}));
```

## Why Defaults Are Required ðŸŽ¯

### 1. **Predictable Behavior** ðŸŽ¯

Defaults ensure that **every component instance has a predictable state**:

```typescript
// âœ… With defaults - always predictable
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  defaults: def.defaults({
    size: "md",
    tone: "default"
  })
}));

// These all produce the same result - predictable!
const button1 = ButtonCls.create(); // Uses defaults: { size: "md", tone: "default" }
const button2 = ButtonCls.create(({ what }) => ({ variant: what.variant({}) })); // Same defaults
const button3 = ButtonCls.create(({ what }) => ({ variant: what.variant({ size: "md" }) })); // Explicit default
```

### 2. **No Undefined States** ðŸ›¡ï¸

Without defaults, you'd have **undefined states** that could cause unpredictable behavior:

```typescript
// âŒ Without defaults - unpredictable behavior
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  // No defaults! What happens when no variants are provided?
}));

// What does this produce? Who knows!
const button = ButtonCls.create(); // Undefined state!
```

### 3. **Type Safety** ðŸ”’

Defaults provide **type safety** by ensuring all variants have known values:

```typescript
// TypeScript knows the exact type of your variants
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  defaults: def.defaults({
    size: "md",     // TypeScript knows size is "sm" | "md" | "lg"
    tone: "default" // TypeScript knows tone is "default" | "primary" | "danger"
  })
}));

// TypeScript can provide perfect IntelliSense
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows exactly what's valid
  })
}));
```

## How Defaults Work ðŸ”„

### Default Resolution Process

When you create a component instance, CLS resolves variants like this:

1. **Start with defaults**: `{ size: "md", tone: "default" }`
2. **Apply user variants**: `{ size: "lg" }` (user only specified size)
3. **Final state**: `{ size: "lg", tone: "default" }` (tone uses default)

```typescript
// Example: User only specifies size
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg" }) // Only size specified
}));

// CLS internally resolves to:
// { size: "lg", tone: "default" }
// Then applies rules based on this complete state
```

### Partial Overrides

You can override **some variants** while leaving others to use defaults:

```typescript
// Override only size, use default tone
const largeButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg" })
}));

// Override only tone, use default size
const primaryButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));

// Override both
const largePrimaryButton = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg", tone: "primary" })
}));
```

## Boolean Variant Defaults ðŸ”˜

Boolean variants also need defaults:

```typescript
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "disabled"]
  },
  slot: ["root"],
  variant: {
    disabled: ["bool"], // Boolean variant
    loading: ["bool"]   // Boolean variant
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      disabled: ["bg-gray-300"]
    }
  }),
  rules: [
    def.root({
      root: what.token(["color.bg.default"])
    }),
    def.rule(
      what.variant({ disabled: true }),
      { root: what.css(["opacity-50", "cursor-not-allowed"]) }
    ),
    def.rule(
      what.variant({ loading: true }),
      { root: what.css(["animate-pulse"]) }
    )
  ],
  defaults: def.defaults({
    disabled: false, // Default to enabled
    loading: false   // Default to not loading
  })
}));
```

## The Alternative: Optional Defaults ðŸ˜±

Without required defaults, you'd have **unpredictable behavior**:

```typescript
// âŒ The "traditional" way (don't do this!)
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... token and rules ...
  // No defaults! What happens when no variants are provided?
}));

// These could all produce different results!
const button1 = ButtonCls.create(); // Maybe uses first variant value?
const button2 = ButtonCls.create(); // Maybe uses random variant value?
const button3 = ButtonCls.create(); // Maybe throws an error?

// No way to know what the "base" state should be!
```

**Problems with optional defaults:**
- **Unpredictable behavior** - different results for same input
- **No clear base state** - what does the component look like by default?
- **Type safety issues** - TypeScript can't guarantee variant values
- **Debugging nightmares** - hard to understand why styles are applied

## Real-World Benefits ðŸŒŸ

### 1. **Consistent Base State**
```typescript
// Every button has a consistent base appearance
const ButtonCls = cls(contract, ({ what, def }) => ({
  defaults: def.defaults({
    size: "md",     // All buttons are medium by default
    tone: "default" // All buttons use default colors by default
  })
}));

// These all look the same by default
<ButtonCls /> // Medium, default colors
<ButtonCls tweak={() => ({})} /> // Same as above
```

### 2. **Clear API Design**
```typescript
// The API is clear about what the default behavior is
const ButtonCls = cls(contract, ({ what, def }) => ({
  defaults: def.defaults({
    size: "md",     // "Buttons are medium by default"
    tone: "default" // "Buttons use default colors by default"
  })
}));
```

### 3. **Type-Safe Variants**
```typescript
// TypeScript knows the complete variant state
ButtonCls.create(({ what }) => ({
  variant: what.variant({ 
    // TypeScript knows size defaults to "md"
    // TypeScript knows tone defaults to "default"
  })
}));
```

## Best Practices for Defaults ðŸ’¡

### 1. **Choose Sensible Defaults**
```typescript
defaults: def.defaults({
  size: "md",     // Most common size
  tone: "default" // Most common tone
})
```

### 2. **Document Your Defaults**
```typescript
// Clear documentation of default behavior
const ButtonCls = cls(contract, ({ what, def }) => ({
  // ... implementation ...
  defaults: def.defaults({
    size: "md",     // Default: Medium size for most use cases
    tone: "default" // Default: Neutral colors for general use
  })
}));
```

### 3. **Consider User Expectations**
```typescript
// Defaults should match user expectations
defaults: def.defaults({
  disabled: false, // Users expect buttons to be enabled by default
  loading: false,  // Users expect buttons to not be loading by default
  size: "md"       // Users expect medium size as the standard
})
```

## The Bottom Line ðŸ’¡

Required defaults provide:

- **Predictable behavior** for every component instance
- **No undefined states** that could cause bugs
- **Type safety** with complete variant information
- **Clear API design** that communicates intent
- **Consistent base state** across your design system
- **Better developer experience** with reliable behavior

Defaults aren't just a convenience - they're a **fundamental requirement** for building reliable, predictable styling systems! ðŸŽ‰

Think of defaults as the **"sensible starting point"** for your components - they ensure that every component instance has a well-defined, predictable state! âœ¨

---

**Previous:** [2.4 Rule-Based System](./2.4-rule-based-system.md) | **Next:** [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
