# 2.4 Rule-Based System

## Table of Contents
- [2.1 Callbacks Everywhere](./2.1-callbacks-everywhere.md)
- [2.2 Why Contracts First](./2.2-why-contracts-first.md)
- [2.3 Token-Centric Design](./2.3-token-centric-design.md)
- [2.4 Rule-Based System](./2.4-rule-based-system.md) *(current)*
- [2.5 Required Defaults](./2.5-required-defaults.md)
- [2.6 Type Safety as Foundation](./2.6-type-safety-as-foundation.md)
- [2.7 Performance by Design](./2.7-performance-by-design.md)
- [2.8 Simplicity Beneath Complexity](./2.8-simplicity-beneath-complexity.md)
- [2.9 CSS Connection](./2.9-css-connection.md)
- [2.10 Inheritance as Foundation](./2.10-inheritance-as-foundation.md)
- [2.11 Declarative Configuration](./2.11-declarative-configuration.md)

---

CLS doesn't just apply styles randomly - it uses a **rule-based system** to map variant combinations to specific slot styles. Think of it as a **decision tree** that says "when this happens, apply that styling"! 🎯

## What Are Rules? 📋

Rules are **conditional statements** that map variant combinations to slot styles. They follow this pattern:

```typescript
// Rule structure
{
  match: { size: "lg", tone: "primary" }, // When these variants are active
  slot: {                                 // Apply these styles to slots
    root: what.token(["color.bg.primary", "spacing.padding.lg"]),
    label: what.css(["text-lg", "font-bold"])
  },
  override: false // Optional: whether to clear previous styles
}
```

## The Rule Evaluation Process 🔄

CLS evaluates rules in **order of definition**, like a cascade:

```typescript
import { cls } from "@use-pico/cls";

const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"],
    "spacing.padding": ["sm", "md", "lg"]
  },
  slot: ["root", "label"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg": {
      default: ["bg-gray-100"],
      primary: ["bg-blue-600"],
      danger: ["bg-red-500"]
    },
    "color.text": {
      default: ["text-gray-900"],
      primary: ["text-white"],
      danger: ["text-white"]
    },
    "spacing.padding": {
      sm: ["px-2", "py-1"],
      md: ["px-4", "py-2"],
      lg: ["px-6", "py-3"]
    }
  }),
  rules: [
    // Rule 1: Base styles (always applied)
    def.root({
      root: what.both(["inline-flex", "items-center", "rounded"], ["color.bg.default", "color.text.default", "spacing.padding.md"]),
      label: what.css(["font-medium"])
    }),
    
    // Rule 2: Primary tone styles
    def.rule(
      what.variant({ tone: "primary" }),
      {
        root: what.token(["color.bg.primary", "color.text.primary"])
      }
    ),
    
    // Rule 3: Large size styles
    def.rule(
      what.variant({ size: "lg" }),
      {
        root: what.token(["spacing.padding.lg"]),
        label: what.css(["text-lg"])
      }
    ),
    
    // Rule 4: Danger tone styles
    def.rule(
      what.variant({ tone: "danger" }),
      {
        root: what.token(["color.bg.danger", "color.text.danger"])
      }
    )
  ],
  defaults: def.defaults({
    size: "md",
    tone: "default"
  })
}));
```

## How Rules Are Evaluated 🧠

When you create a button with `{ size: "lg", tone: "primary" }`, CLS evaluates rules like this:

1. **Start with defaults**: `{ size: "md", tone: "default" }`
2. **Apply user variants**: `{ size: "lg", tone: "primary" }`
3. **Evaluate rules in order**:
   - Rule 1 (base): ✅ Always matches → Apply base styles
   - Rule 2 (primary): ✅ `tone: "primary"` matches → Apply primary styles
   - Rule 3 (large): ✅ `size: "lg"` matches → Apply large styles
   - Rule 4 (danger): ❌ `tone: "danger"` doesn't match → Skip

**Result**: Base + Primary + Large styles are combined! 🎉

## Rule Matching Logic 🎯

Rules use **exact matching** for variants:

```typescript
// ✅ This rule matches when size is "lg"
def.rule(
  what.variant({ size: "lg" }),
  { root: what.css(["text-lg"]) }
);

// ✅ This rule matches when tone is "primary" AND size is "lg"
def.rule(
  what.variant({ size: "lg", tone: "primary" }),
  { root: what.css(["shadow-lg"]) }
);

// ✅ This rule matches when disabled is true
def.rule(
  what.variant({ disabled: true }),
  { root: what.css(["opacity-50", "cursor-not-allowed"]) }
);
```

## Append vs Override Behavior 🔄

Rules can either **append** to previous styles or **override** them completely:

```typescript
rules: [
  // Base rule - always applied first
  def.root({
    root: what.css(["inline-flex", "items-center", "rounded"])
  }),
  
  // Append rule - adds to base styles
  def.rule(
    what.variant({ tone: "primary" }),
    {
      root: what.token(["color.bg.primary", "color.text.primary"])
    }
    // override: false (default) - appends to previous styles
  ),
  
  // Override rule - clears previous styles and applies only these
  override.rule(
    what.variant({ disabled: true }),
    {
      root: what.css(["opacity-50", "cursor-not-allowed", "bg-gray-300"])
    }
  )
]
```

## Complex Rule Examples 🌟

### Multiple Variant Combinations
```typescript
// Rule that only applies when multiple conditions are met
def.rule(
  what.variant({ size: "lg", tone: "primary", disabled: false }),
  {
    root: what.css(["shadow-lg", "hover:shadow-xl"])
  }
);
```

### Boolean Variants
```typescript
// Rules for boolean variants
def.rule(
  what.variant({ loading: true }),
  {
    root: what.css(["opacity-75", "cursor-not-allowed"]),
    label: what.css(["animate-pulse"])
  }
);
```

## Rule Precedence 📊

Rules are evaluated in **definition order** - later rules can override earlier ones:

```typescript
rules: [
  // Rule 1: Base styles
  def.root({
    root: what.css(["inline-flex", "items-center"])
  }),
  
  // Rule 2: Primary tone
  def.rule(
    what.variant({ tone: "primary" }),
    { root: what.css(["bg-blue-600", "text-white"]) }
  ),
  
  // Rule 3: Danger tone (overrides primary)
  def.rule(
    what.variant({ tone: "danger" }),
    { root: what.css(["bg-red-500", "text-white"]) }
  )
]
```

For `{ tone: "danger" }`, Rule 1 + Rule 3 are applied (Rule 2 is skipped).

## The Alternative: Conditional Styling 😱

Without rules, you'd have to write **imperative conditional logic**:

```typescript
// ❌ The "traditional" way (don't do this!)
function getButtonClasses(variants) {
  let classes = "inline-flex items-center rounded";
  
  if (variants.tone === "primary") {
    classes += " bg-blue-600 text-white";
  } else if (variants.tone === "danger") {
    classes += " bg-red-500 text-white";
  }
  
  if (variants.size === "lg") {
    classes += " px-6 py-3 text-lg";
  } else if (variants.size === "sm") {
    classes += " px-2 py-1 text-sm";
  }
  
  if (variants.disabled) {
    classes += " opacity-50 cursor-not-allowed";
  }
  
  return classes;
}
```

**Problems with this approach:**
- **Imperative logic** - hard to read and maintain
- **No type safety** - typos and invalid variants
- **No IntelliSense** - no autocomplete for variants
- **Hard to test** - complex conditional logic
- **Inconsistent** - different developers write different logic

## Real-World Benefits 🌟

### 1. **Declarative Styling**
```typescript
// Rules read like UI requirements
rules: [
  def.rule(
    what.variant({ tone: "primary" }),
    { root: what.token(["color.bg.primary", "color.text.primary"]) }
  ),
  def.rule(
    what.variant({ size: "lg" }),
    { root: what.token(["spacing.padding.lg"]) }
  )
]
// "When tone is primary, use primary colors"
// "When size is large, use large padding"
```

### 2. **Predictable Behavior**
```typescript
// Rules are evaluated in order - predictable results
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ size: "lg", tone: "primary" })
}));
// Always: Base + Primary + Large styles
```

### 3. **Type-Safe Rules**
```typescript
// TypeScript ensures valid variant combinations
def.rule(
  what.variant({ 
    size: "lg",     // ✅ Valid
    tone: "primary" // ✅ Valid
    // invalid: "value" // ❌ TypeScript error
  }),
  { root: what.css(["custom-styles"]) }
);
```

## The Bottom Line 💡

Rule-based styling provides:

- **Declarative logic** that reads like UI requirements
- **Predictable evaluation** in definition order
- **Type-safe rules** with compile-time validation
- **Flexible matching** for simple and complex conditions
- **Append/override control** for precise styling behavior
- **Maintainable code** that's easy to understand and modify

Rules transform styling from **imperative conditional logic** into **declarative statements** that clearly express your design intent! 🎉

Think of rules as **"if-then" statements for your UI** - they make your styling logic explicit, predictable, and maintainable! ✨

---

**Previous:** [2.3 Token-Centric Design](./2.3-token-centric-design.md) | **Next:** [2.5 Required Defaults](./2.5-required-defaults.md)
