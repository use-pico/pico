# 1.2 Mental Model

## Table of Contents
- [1.1 What is CLS?](./1.1-what-is-cls.md)
- [1.2 Mental Model](./1.2-mental-model.md) *(current)*
- [1.3 Motivation](./1.3-motivation.md)
- [1.4 Installation](./1.4-installation.md)
- [1.5 Quick Start](./1.5-quick-start.md)

---

Alright, let's talk about the **mental model** behind CLS! ğŸ§ âœ¨

The CLS mental model is built on two powerful pillars: **contract-first design** and **heavy typechecking**. Think of it like building a house â€“ you start with a solid foundation and detailed blueprints, then everything else just flows naturally from there! ğŸ—ï¸

## Contract-First: Define Once, Use Everywhere ğŸ“‹

In CLS, you start by defining **what's available** down the stream. You decide what tokens, slots, and variants your module will have, and how they all fit together. Once that's done, you can use these building blocks everywhere without wondering what's available! ğŸ¯

```typescript
// Define your contract first (the "menu")
const ButtonCls = cls({
  tokens: {
    "color.bg": ["default", "primary", "danger"],
    "color.text": ["default", "primary", "danger"]
  },
  slot: ["root", "label", "icon"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["default", "primary", "danger"]
  }
}, definition);
```

**The magic?** Once you define this contract, TypeScript becomes your best friend and knows exactly what's available everywhere! ğŸ¯

## Heavy Typechecking: Your Safety Net ğŸ›¡ï¸

CLS doesn't just do type checking â€“ it does **heavy typechecking**. We're talking about the kind of type safety that catches mistakes before you even run your code. It's like having a very picky code reviewer who never sleeps and catches every single error! ğŸ˜´â¡ï¸ğŸ‘ï¸

**Invalid variants?** TypeScript will scream at you! ğŸš¨ **Wrong token names?** Nope, not happening! âŒ **Missing slots?** Forget about it! ğŸš« **Type mismatches?** Caught at compile time! ğŸ¯

## The "Feel It" Philosophy ğŸŒŸ

Here's the beautiful part: once you understand the contract-first approach and embrace the type safety, the rest just **feels natural** from the code and design. It's like learning to ride a bike â€“ at first, you're focused on balance and pedaling, but soon you're just cruising and enjoying the ride! ğŸš´â€â™‚ï¸

**You'll find yourself thinking:** *"I need a button variant? Let me check the contract!"* ğŸ“– *"What tokens are available? TypeScript will tell me!"* ğŸ’¡ *"How do I extend this? The extend method knows what to do!"* ğŸ”§

## The Three Core Concepts ğŸ¯

### 1. Contracts (The Blueprint) ğŸ“

Contracts are like **blueprints** for your styling system. They define:
- **What tokens exist** and what variants they have
- **What slots are available** for styling
- **What variants can be applied** to change appearance

Think of contracts as the "menu" â€“ you can only order what's on the menu, but once it's there, you know exactly what you're getting! ğŸ½ï¸

### 2. Definitions (The Implementation) ğŸ—ï¸

Definitions are where you **implement** your contract. They provide:
- **Token values** (what CSS classes each token expands to)
- **Slot styling** (how each slot looks by default)
- **Rules** (how variants change the styling)

This is where the magic happens â€“ you take your blueprint and turn it into actual, working styles! âœ¨

### 3. Instances (The Usage) ğŸ®

Instances are what you **use** in your code. They provide:
- **Slot functions** that return CSS classes
- **Type-safe variant overrides**
- **Runtime customization** capabilities

This is where you get the benefits â€“ clean, predictable, type-safe styling! ğŸ‰

## The Inheritance Mindset ğŸ§¬

CLS embraces **composition over inheritance**, but with a twist. Instead of complex inheritance hierarchies, you have **simple, clear inheritance chains**:

```typescript
// Start with tokens only
const ThemeCls = cls(themeContract, themeDefinition);

// Extend with module-specific stuff
const ButtonCls = ThemeCls.extend(buttonContract, buttonDefinition);

// Use in your components
const classes = ButtonCls.create(({ what }) => ({
  variant: what.variant({ tone: "primary" })
}));
```

**The beauty?** Each level adds exactly what it needs, and TypeScript keeps track of everything! ğŸ¯

## Why This Mental Model Works ğŸ¯

### Predictability ğŸ“Š
Because everything is defined upfront in contracts, you always know what's available. No more guessing what props a component accepts or what classes it might generate.

### Safety ğŸ›¡ï¸
TypeScript catches errors at compile time, so you spend less time debugging styling issues and more time building features.

### Composability ğŸ§©
You can mix and match contracts, extend them, and compose them together. It's like having LEGO bricks for styling systems!

### Maintainability ğŸ”§
When you need to change something, you change it in one place (the contract or definition), and TypeScript ensures everything else stays in sync.

## The Learning Curve ğŸ“ˆ

**Phase 1: "This looks complicated"** ğŸ˜°
- First encounter with contracts and definitions
- Lots of TypeScript types to understand

**Phase 2: "I see the pattern"** ğŸ¤”
- Contracts define structure, definitions provide values
- TypeScript guides you through the process

**Phase 3: "This is actually simple"** ğŸ˜Œ
- Everything follows the same pattern
- TypeScript does the heavy lifting

**Phase 4: "I can't live without this"** ğŸš€
- Clean, predictable styling everywhere
- Type safety prevents countless bugs

## The Bottom Line ğŸ’¡

CLS's mental model is about **embracing constraints to gain freedom**. By defining your styling system upfront with contracts, you get:

- **Type safety** that prevents errors
- **IntelliSense** that guides development
- **Composability** that enables reuse
- **Predictability** that reduces bugs

It's like having a **styling system that thinks for you** â€“ you focus on what you want to build, and CLS handles the complexity of making it work correctly! ğŸ§ âœ¨

---

**Previous:** [1.1 What is CLS?](./1.1-what-is-cls.md) | **Next:** [1.3 Motivation](./1.3-motivation.md)
