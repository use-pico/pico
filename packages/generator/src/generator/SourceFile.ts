import {
    diffOf,
    generateId
}                             from "@use-pico/utils";
import {
    appendFileSync,
    existsSync,
    mkdirSync,
    readFileSync,
    writeFileSync
}                             from "node:fs";
import {
    basename,
    dirname,
    normalize
}                             from "node:path";
import {type IExportable}     from "../api/IExportable";
import {type IWithClasses}    from "../api/IWithClasses";
import {type IWithConsts}     from "../api/IWithConsts";
import {type IWithExports}    from "../api/IWithExports";
import {type IWithImports}    from "../api/IWithImports";
import {type IWithInterfaces} from "../api/IWithInterfaces";
import {type IWithTypes}      from "../api/IWithTypes";
import {resolvePackageJson}   from "../utils/resolvePackageJson";
import {Classes}              from "./Classes";
import {Consts}               from "./Consts";
import {Exports}              from "./Exports";
import {Imports}              from "./Imports";
import {Interfaces}           from "./Interfaces";
import {Types}                from "./Types";

export class SourceFile implements IExportable {
    public $header?: string;
    public readonly $imports: Imports;
    public readonly $types: Types;
    public readonly $interfaces: Interfaces;
    public readonly $classes: Classes;
    public readonly $consts: Consts;
    public readonly $exports: Exports;

    constructor() {
        this.$header = `
    This is a file generated by MCP (managed code pattern) approach.
    
    So, please, DO NOT modify this file as it would get re-generated and you would be f*cked up.
`;
        this.$imports = new Imports();
        this.$types = new Types();
        this.$interfaces = new Interfaces();
        this.$classes = new Classes();
        this.$consts = new Consts();
        this.$exports = new Exports();
    }

    public withHeader(comment?: string) {
        this.$header = comment;
        return this;
    }

    public withImports({imports}: IWithImports | undefined = {imports: {}}) {
        Object.entries(imports).map(([key, value]) => this.$imports.withImport(key, value));
        return this;
    }

    public withConsts({
                          consts = {},
                          exports = {}
                      }: IWithConsts | undefined = {
        consts:  {},
        exports: {}
    }) {
        Object.entries(consts).map(([key, value]) => this.$consts.const(key, value, false));
        Object.entries(exports).map(([key, value]) => this.$consts.const(key, value, true));
        return this;
    }

    public withTypes({
                         types = {},
                         exports = {}
                     }: IWithTypes | undefined = {
        types:   {},
        exports: {}
    }) {
        Object.entries(types).map(([key, value]) => this.$types.type(key, value, false));
        Object.entries(exports).map(([key, value]) => this.$types.type(key, value, true));
        return this;
    }

    public withInterfaces({
                              interfaces = {},
                              exports = {}
                          }: IWithInterfaces | undefined = {
        interfaces: {},
        exports:    {}
    }) {
        Object.entries(interfaces).map(([key, value]) => this.$interfaces.interface(key, value, false));
        Object.entries(exports).map(([key, value]) => this.$interfaces.interface(key, value, true));
        return this;
    }

    public withClasses({
                           classes = {},
                           exports = {}
                       }: IWithClasses | undefined = {
        classes: {},
        exports: {}
    }) {
        Object.entries(classes).map(([key, value]) => this.$classes.interface(key, value, false));
        Object.entries(exports).map(([key, value]) => this.$classes.interface(key, value, true));
        return this;
    }

    public withExports({exportsOf}: IWithExports) {
        exportsOf && this.$exports.exportsOf(exportsOf);
        return this;
    }

    public export() {
        return (this.$header ? `/**\n\t${this.$header.trim()}\n */\n` : "") + ([
            this.$imports,
            this.$types,
            this.$interfaces,
            this.$classes,
            this.$consts,
            this.$exports,
        ] as const).map(item => item.export().trim()).filter(Boolean).join("\n\n");
    }

    public saveTo({
                      file,
                      barrel,
                      silent = false
                  }: SourceFile.ISaveToProps) {
        this.withConsts({
            exports: {
                [`$leight_${generateId()}`]: {
                    body:    "true",
                    comment: `
/**
 * Default export marking a file it's generated and also preventing failing
 * an empty file export (every module "must" have an export).
 */
                    `,
                },
            }
        });
        mkdirSync(dirname(file), {recursive: true});
        writeFileSync(file, this.export(), {
            flag:     "w+",
            encoding: "utf8",
        });
        if (barrel) {
            const filename = basename(file).replace(".tsx", "").replace(".ts", "");
            const index = normalize(`${dirname(file)}/index.ts`);
            if (!existsSync(index) || !readFileSync(index, {encoding: "utf8"})?.includes(filename)) {
                appendFileSync(index, `export * from "./${filename}";\n`, {
                    encoding: "utf8",
                });
            }
        }

        const dependencies = Object.keys(resolvePackageJson().dependencies || {});
        const required = this.$imports.list();
        const diff = diffOf(required, dependencies);

        if (diff.length) {
            console.log("Current packages", dependencies);
            console.log("Required packages", required);
            console.log("- You should install", diff, "\n\n");
            if (!silent) {
                throw new Error("Missing dependencies");
            }
        }

        return this;
    }
}

export namespace SourceFile {
    export interface ISaveToProps {
        file: string;
        barrel: boolean;
        /**
         * Suppress an exception if there are missing dependencies; defaults to false
         */
        silent?: boolean;
    }
}

export const withSourceFile = () => {
    return new SourceFile();
};
