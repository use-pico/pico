# 13.4 vs CVA (Class Variance Authority)

## Table of Contents
- [13.1 Feature Table](./13.1-feature-table.md)
- [13.2 Code Comparisons](./13.2-code-comparisons.md)
- [13.3 Migration Paths](./13.3-migration-paths.md)
- [13.4 vs CVA (Class Variance Authority)](./13.4-vs-cva-class-variance-authority.md) *(current)*
- [13.5 vs TV (Tailwind Variants)](./13.5-vs-tv-tailwind-variants.md)
- [13.6 vs Stitches](./13.6-vs-stitches.md)
- [13.7 vs Vanilla Extract](./13.7-vs-vanilla-extract.md)

---

This chapter provides a **detailed comparison** between CLS and **Class Variance Authority (CVA)**, one of the most popular variant-based styling solutions. We'll explore their **similarities**, **differences**, and **when to choose each**.

## **What is CVA?** ü§î

**Class Variance Authority (CVA)** is a popular TypeScript-first styling library that provides **variant-based styling** with excellent TypeScript support. It's designed to work seamlessly with **Tailwind CSS** and other utility-first frameworks.

### **CVA's Core Philosophy** üéØ

- **Variant-first approach** - Define variants and their combinations
- **TypeScript integration** - Full type safety for variants and props
- **Utility-first compatibility** - Works with Tailwind CSS and similar frameworks
- **Simple API** - Minimal learning curve and straightforward usage
- **Framework agnostic** - Works with any React setup

## **Side-by-Side Comparison** üìä

### **Basic Button Component** üéØ

Let's compare how both libraries handle a simple button component with size and tone variants.

#### **CVA Implementation** üì¶

```typescript
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center rounded font-medium transition-colors",
  {
    variants: {
      size: {
        sm: "px-3 py-1.5 text-sm",
        md: "px-4 py-2 text-base",
        lg: "px-6 py-3 text-lg",
      },
      tone: {
        primary: "bg-blue-600 text-white focus:ring-blue-500",
        secondary: "bg-gray-600 text-white focus:ring-gray-500",
        danger: "bg-red-600 text-white focus:ring-red-500",
      },
    },
    defaultVariants: {
      size: "md",
      tone: "primary",
    },
  }
);

interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  children: React.ReactNode;
}

function Button({ children, size, tone, className, ...props }: ButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ size, tone }), className)}
      {...props}
    >
      {children}
    </button>
  );
}
```

#### **CLS Implementation** ‚ú®

```typescript
import { cls } from "@use-pico/cls";
import { useCls } from "@use-pico/cls/react";
import type { Component } from "@use-pico/cls";

// Define the CLS instance
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary", "danger"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.bg.danger": ["bg-red-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "color.text.danger": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.root({
      root: what.css([
        "inline-flex items-center justify-center rounded font-medium transition-colors"
      ])
    }),
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary", "focus:ring-blue-500"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary", "color.text.secondary", "focus:ring-gray-500"])
    }),
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger", "focus:ring-red-500"])
    })
  ],
  defaults: def.defaults({
    size: "md",
    tone: "primary"
  })
}));

// React component
interface ButtonProps extends Component<typeof ButtonCls, React.ButtonHTMLAttributes<HTMLButtonElement>> {
  children: React.ReactNode;
  size?: "sm" | "md" | "lg";
  tone?: "primary" | "secondary" | "danger";
}

function Button({
  children,
  size = "md",
  tone = "primary",
  tva = ButtonCls,
  cls,
  ...props
}: ButtonProps) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({
      size,
      tone
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      {children}
    </button>
  );
}
```

## **Key Differences Analysis** üîç

### **1. Architecture Philosophy** üèóÔ∏è

| Aspect | CVA | CLS |
|--------|-----|-----|
| **Core Approach** | Variant-based styling | Contract-first design |
| **Design Philosophy** | Simple and straightforward | Type-safe and scalable |
| **Learning Curve** | Easy to learn | Medium learning curve |
| **Scalability** | Good for simple cases | Excellent for complex systems |

**CVA**: **Simple and direct** - focuses on making variant-based styling easy and accessible.

**CLS**: **Comprehensive and scalable** - prioritizes type safety, inheritance, and design system architecture.

### **2. Type Safety** üõ°Ô∏è

#### **CVA Type Safety** üì¶

```typescript
// CVA provides good type safety for variants
const buttonVariants = cva("base", {
  variants: {
    size: { sm: "text-sm", md: "text-base", lg: "text-lg" },
    tone: { primary: "bg-blue-600", secondary: "bg-gray-600" }
  }
});

// TypeScript infers variant types
type ButtonVariants = VariantProps<typeof buttonVariants>;
// Result: { size?: "sm" | "md" | "lg"; tone?: "primary" | "secondary" }
```

#### **CLS Type Safety** ‚ú®

```typescript
// CLS provides comprehensive type safety
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  // Contract validation ensures all variants are properly defined
  rules: [
    def.rule({
      variant: { size: "sm" }, // TypeScript validates this
      root: what.css(["text-sm"])
    })
  ]
}));

// Full type safety with contract validation
interface ButtonProps extends Component<typeof ButtonCls> {
  // TypeScript ensures all props match the contract
}
```

**Winner**: **CLS** - Provides **comprehensive type safety** with contract validation, while CVA offers **good but limited** type safety.

### **3. Design Tokens** üé®

#### **CVA Design Tokens** üì¶

```typescript
// CVA has no built-in design token system
const buttonVariants = cva("base", {
  variants: {
    size: {
      sm: "px-3 py-1.5 text-sm", // Hardcoded values
      md: "px-4 py-2 text-base",
      lg: "px-6 py-3 text-lg"
    },
    tone: {
      primary: "bg-blue-600 text-white", // Hardcoded values
      secondary: "bg-gray-600 text-white"
    }
  }
});
```

#### **CLS Design Tokens** ‚ú®

```typescript
// CLS has native design token system
const ButtonCls = cls({
  slot: ["root"],
  variant: {
    size: ["sm", "md", "lg"],
    tone: ["primary", "secondary"]
  }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"],
    "color.text.primary": ["text-white"],
    "color.text.secondary": ["text-white"],
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["spacing.sm"]) // Uses tokens
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"]) // Uses tokens
    })
  ]
}));
```

**Winner**: **CLS** - Provides **native design token system** with inheritance and runtime overrides, while CVA requires **manual organization**.

### **4. Inheritance & Composition** üèóÔ∏è

#### **CVA Inheritance** üì¶

```typescript
// CVA has no built-in inheritance system
const baseButton = cva("base", {
  variants: { size: { sm: "text-sm", md: "text-base" } }
});

const primaryButton = cva("base", {
  variants: { size: { sm: "text-sm", md: "text-base" } }
}); // Duplicate code

const dangerButton = cva("base", {
  variants: { size: { sm: "text-sm", md: "text-base" } }
}); // More duplicate code
```

#### **CLS Inheritance** ‚ú®

```typescript
// CLS has multi-level inheritance
const BaseButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"] }
}, ({ what, def }) => ({
  token: def.token({
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    }),
    def.rule({
      variant: { size: "md" },
      root: what.css(["text-base", "spacing.md"])
    }),
    def.rule({
      variant: { size: "lg" },
      root: what.css(["text-lg", "spacing.lg"])
    })
  ]
}));

// Inherit and extend
const PrimaryButtonCls = BaseButtonCls.extend({
  variant: { tone: ["primary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.text.primary": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"])
    })
  ]
}));

const DangerButtonCls = BaseButtonCls.extend({
  variant: { tone: ["danger"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.danger": ["bg-red-600"],
    "color.text.danger": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "danger" },
      root: what.css(["color.bg.danger", "color.text.danger"])
    })
  ]
}));
```

**Winner**: **CLS** - Provides **multi-level inheritance** and **composition**, while CVA requires **manual code duplication**.

### **5. Runtime Flexibility** ‚ö°

#### **CVA Runtime Limitations** üì¶

```typescript
// CVA has no runtime overrides
const buttonVariants = cva("base", {
  variants: {
    tone: {
      primary: "bg-blue-600",
      secondary: "bg-gray-600"
    }
  }
});

// Can't dynamically change colors at runtime
function Button({ tone, ...props }) {
  return (
    <button className={buttonVariants({ tone })} {...props}>
      Click me
    </button>
  );
}
```

#### **CLS Runtime Flexibility** ‚ú®

```typescript
// CLS supports runtime overrides
const ButtonCls = cls({
  slot: ["root"],
  variant: { tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    }),
    def.rule({
      variant: { tone: "secondary" },
      root: what.css(["color.bg.secondary"])
    })
  ]
}));

// Runtime override for dark theme
function Button({ tone, isDarkTheme, ...props }) {
  const buttonClasses = useCls(ButtonCls, ({ what, override }) => ({
    variant: what.variant({ tone }),
    token: override.token({
      "color.bg.primary": isDarkTheme ? ["bg-blue-800"] : ["bg-blue-600"]
    })
  }));

  return (
    <button className={buttonClasses.root()} {...props}>
      Click me
    </button>
  );
}
```

**Winner**: **CLS** - Provides **full runtime flexibility** with token overrides, while CVA is **static only**.

### **6. Bundle Size** üì¶

| Metric | CVA | CLS |
|--------|-----|-----|
| **Bundle Size** | ~5KB | ~15KB |
| **Runtime Overhead** | Minimal | Medium |
| **Tree Shaking** | Excellent | Good |
| **Dependencies** | Minimal | Moderate |

**Winner**: **CVA** - **Smaller bundle size** and **minimal runtime overhead**.

### **7. Developer Experience** üë®‚Äçüíª

#### **CVA Developer Experience** üì¶

**Pros:**
- **Easy to learn** - Simple API with minimal concepts
- **Quick prototyping** - Fast to get started
- **Familiar patterns** - Similar to other variant libraries
- **Good TypeScript support** - Type inference for variants

**Cons:**
- **Limited scalability** - No inheritance or composition
- **No design tokens** - Manual organization required
- **Static styling** - No runtime flexibility
- **Code duplication** - No way to share common patterns

#### **CLS Developer Experience** ‚ú®

**Pros:**
- **Excellent type safety** - Contract validation and IntelliSense
- **Scalable architecture** - Inheritance and composition
- **Design token system** - Organized and reusable values
- **Runtime flexibility** - Dynamic theming and overrides
- **Predictable APIs** - Consistent patterns across components

**Cons:**
- **Learning curve** - More concepts to understand
- **Larger bundle size** - More features = more code
- **Complexity** - May be overkill for simple use cases

**Winner**: **Tie** - Depends on **project requirements** and **team expertise**.

## **Use Case Recommendations** üéØ

### **Choose CVA When You Need:** ‚úÖ

- **Simple variant-based styling** with TypeScript
- **Quick prototyping** and rapid development
- **Minimal bundle size** and runtime overhead
- **Familiar patterns** for teams new to styling systems
- **Tailwind CSS integration** with type safety
- **Small to medium projects** with simple styling needs

### **Choose CLS When You Need:** ‚úÖ

- **Type-safe design systems** with complex inheritance
- **Runtime theming** and user customization
- **Multi-framework support** across different environments
- **Design token management** with inheritance and overrides
- **Complex conditional styling** with rule-based logic
- **Team collaboration** with predictable APIs
- **Large-scale applications** with complex styling requirements

## **Migration Complexity** üõ§Ô∏è

### **From CVA to CLS** üìà

**Complexity**: üü° Medium (2-4 weeks)

**Key Challenges:**
- **Learning contracts and tokens** - New concepts to understand
- **Architecture planning** - Designing inheritance hierarchy
- **Code restructuring** - Moving from variants to contracts
- **Team training** - Teaching new patterns and concepts

**Migration Steps:**
1. **Install CLS** and remove CVA dependency
2. **Create CLS contracts** for each component
3. **Define design tokens** for consistent values
4. **Migrate component interfaces** to use `Component<T>`
5. **Replace `cn()` calls** with `useCls()` hook
6. **Test all variant combinations** work correctly

### **From CLS to CVA** üìâ

**Complexity**: üü¢ Easy (1-2 weeks)

**Key Challenges:**
- **Losing features** - No inheritance, tokens, or runtime overrides
- **Code duplication** - Manual organization of common patterns
- **Type safety reduction** - Less comprehensive type checking
- **Architecture simplification** - Moving from complex to simple

## **Performance Comparison** ‚ö°

### **Runtime Performance** üèÉ‚Äç‚ôÇÔ∏è

| Metric | CVA | CLS |
|--------|-----|-----|
| **Class Generation** | Fast | Fast |
| **Memory Usage** | Low | Medium |
| **Bundle Size** | Small | Medium |
| **Tree Shaking** | Excellent | Good |

**CVA**: **Optimized for performance** with minimal runtime overhead.

**CLS**: **Balanced performance** with additional features and type safety.

### **Development Performance** üë®‚Äçüíª

| Metric | CVA | CLS |
|--------|-----|-----|
| **Learning Speed** | Fast | Medium |
| **Development Speed** | Fast (simple) | Fast (complex) |
| **Refactoring Safety** | Good | Excellent |
| **Team Onboarding** | Easy | Medium |

**CVA**: **Fast development** for simple use cases.

**CLS**: **Fast development** for complex systems with better safety.

## **Real-World Examples** üåç

### **Simple Component Library** üìö

**CVA Example:**
```typescript
// Simple button library with CVA
const buttonVariants = cva("base", {
  variants: {
    size: { sm: "text-sm", md: "text-base", lg: "text-lg" },
    tone: { primary: "bg-blue-600", secondary: "bg-gray-600" }
  }
});

// Works great for simple cases
function Button({ size, tone, ...props }) {
  return <button className={buttonVariants({ size, tone })} {...props} />;
}
```

**CLS Example:**
```typescript
// Comprehensive button library with CLS
const ButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"], tone: ["primary", "secondary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.bg.secondary": ["bg-gray-600"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm"])
    }),
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary"])
    })
  ]
}));

// More setup but better for complex systems
function Button({ size, tone, tva = ButtonCls, cls, ...props }) {
  const buttonClasses = useCls(tva, cls, ({ what }) => ({
    variant: what.variant({ size, tone })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

### **Complex Design System** üé®

**CVA Limitations:**
```typescript
// CVA struggles with complex inheritance
const baseButton = cva("base", { variants: { size: { sm: "text-sm" } } });
const primaryButton = cva("base", { variants: { size: { sm: "text-sm" } } }); // Duplicate
const dangerButton = cva("base", { variants: { size: { sm: "text-sm" } } }); // Duplicate

// No way to share common patterns
// No design token system
// No runtime theming
```

**CLS Advantages:**
```typescript
// CLS excels with complex inheritance
const BaseButtonCls = cls({
  slot: ["root"],
  variant: { size: ["sm", "md", "lg"] }
}, ({ what, def }) => ({
  token: def.token({
    "spacing.sm": ["px-3 py-1.5"],
    "spacing.md": ["px-4 py-2"],
    "spacing.lg": ["px-6 py-3"]
  }),
  rules: [
    def.rule({
      variant: { size: "sm" },
      root: what.css(["text-sm", "spacing.sm"])
    })
  ]
}));

// Inherit and extend
const PrimaryButtonCls = BaseButtonCls.extend({
  variant: { tone: ["primary"] }
}, ({ what, def }) => ({
  token: def.token({
    "color.bg.primary": ["bg-blue-600"],
    "color.text.primary": ["text-white"]
  }),
  rules: [
    def.rule({
      variant: { tone: "primary" },
      root: what.css(["color.bg.primary", "color.text.primary"])
    })
  ]
}));

// Runtime theming
function ThemedButton({ theme, ...props }) {
  const buttonClasses = useCls(PrimaryButtonCls, ({ override }) => ({
    token: override.token({
      "color.bg.primary": theme === "dark" ? ["bg-blue-800"] : ["bg-blue-600"]
    })
  }));
  return <button className={buttonClasses.root()} {...props} />;
}
```

## **The Bottom Line** üí°

### **CVA is Perfect For:** üéØ

- **Simple projects** with basic styling needs
- **Quick prototyping** and rapid development
- **Teams new to styling systems** who want to learn gradually
- **Projects where bundle size** is critical
- **Simple component libraries** without complex inheritance

### **CLS is Perfect For:** üéØ

- **Complex design systems** with inheritance and composition
- **Large-scale applications** requiring type safety and scalability
- **Teams building maintainable** and extensible styling systems
- **Projects requiring runtime theming** and user customization
- **Multi-framework environments** where consistency is crucial

### **The Choice Depends On:** ü§î

- **Project complexity** and scale
- **Team expertise** and learning capacity
- **Performance requirements** and constraints
- **Long-term maintainability** goals
- **Design system ambitions** and scope

**CVA** is the **simple, fast solution** for straightforward styling needs.

**CLS** is the **comprehensive, scalable solution** for complex design systems.

Choose the tool that matches your **project requirements** and **team capabilities**! üöÄ

---

**[‚Üê Previous: Migration Paths](./13.3-migration-paths.md)** | **[‚Üí Next: vs TV](./13.5-vs-tv-tailwind-variants.md)**
